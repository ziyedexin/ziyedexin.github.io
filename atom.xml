<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>子夜の博客</title>
  
  
  <link href="https://www.zxhy.club/atom.xml" rel="self"/>
  
  <link href="https://www.zxhy.club/"/>
  <updated>2023-06-09T08:59:30.931Z</updated>
  <id>https://www.zxhy.club/</id>
  
  <author>
    <name>子夜的星</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初探MySQL：数据库基本操作</title>
    <link href="https://www.zxhy.club/posts/sql1.html"/>
    <id>https://www.zxhy.club/posts/sql1.html</id>
    <published>2023-06-09T07:20:00.000Z</published>
    <updated>2023-06-09T08:59:30.931Z</updated>
    
    <content type="html"><![CDATA[<h1>一、数据库操作</h1><p>数据库操作：</p><ul><li>用户在客户端输入SQL</li><li>客户端会把SQL通过网络发送给服务器</li><li>服务器执行这个SQL</li><li>客户端收到结果，显示到界面上</li></ul><h2 id="1、创建数据库：">1、创建数据库：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database 数据库名;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database java108 charset utf8;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li><p><code>create</code> <code>database</code> 相当于一个关键字</p></li><li><p><strong>SQL中不会区分大小写</strong></p></li><li><p><strong>创建的数据库名可以随便取，但是不能重复</strong></p></li><li><p><code>character set</code>：<strong>指定数据库采用的字符集</strong></p></li></ul><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202306071609672.png" alt="image-20230607160924603"></p><p>看见OK说明创建成功。</p><h2 id="2、查看所有数据库">2、查看所有数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202306071621109.png" alt="image-20230607162105072"></p><p>红圈中的四个都是系统自带的数据库。</p><h2 id="3、选中指定数据库">3、选中指定数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure><p>一旦选定了某个数据库，后续操作，就是针对该数据库展开了。</p><h2 id="4、删除数据库">4、删除数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database 数据库名;</span><br></pre></td></tr></table></figure><p>该操作属于危险操作！！！一旦删除数据库，数据库中的所有数据都没有了，很难恢复。</p><p>如何预防危险操作：</p><ul><li>权限：不同的用户能进行的操作是不一样的。</li><li>备份：一旦不小心删除数据，通过备份数据恢复。</li><li>检查：重要操作的时候，多人进行检查。</li></ul><h1>二、数据表操作</h1><p>关系型数据库中，数据是以“表”的方式来进行组织的（类似于excel）。</p><p>每个数据库中，里面可以有很多的数据表，每个表可以有很多行，每一行可以有很多列。</p><h2 id="1、创建表">1、创建表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table 表名（列名类型,列名类型....）;</span><br></pre></td></tr></table></figure><p>MySQL本身也支持很多的数据类型。</p><p>大概熟悉几个常用的数据类型：<code>int</code>，<code>bigint</code>，<code>varchar</code>，<code>double</code>，<code>decimal</code>，<code>datetime</code></p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202306071743263.png" alt="image-20230607174342226"></p><p>上述报错原因：没有选中数据库！<strong>所有和表有关的操作，都需要先选定数据库。</strong></p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202306071744233.png" alt="image-20230607174441200"></p><h2 id="2、查看当前数据库的所有表">2、查看当前数据库的所有表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202306071807313.png" alt="image-20230607180714276"></p><h2 id="3、查看制定表的表结构">3、查看制定表的表结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc 表名;</span><br></pre></td></tr></table></figure><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202306071811550.png" alt="image-20230607181159511"></p><p><code>Field</code>表示字段（一行里面有几列）<code>Type</code>表示每一列的类型。</p><p><code>int</code>括号内的11表示，打印的时候最多占11个字符这么宽。YES表示允许为空，可写可不写。</p><p><code>Default</code>表示默认，即不填写的时默认的值。</p><p><code>Extra</code>表示额外的补充信息。</p><h2 id="4、删除表">4、删除表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table 表名;</span><br></pre></td></tr></table></figure><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202306071818408.png" alt="image-20230607181834373"></p><h1>三、课后训练</h1><h2 id="1、设计一张商品表">1、设计一张商品表</h2><p>设计一张商品表，包含以下字段：商品goods(商品编号goods_id，商品名goods_name, 单价unitprice, 商品类别category, 供应商provider)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table goods (goodid int,goodname varchar(20),unitprice int,category varchar(50),provider varchar(50));</span><br></pre></td></tr></table></figure><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202306071831844.png" alt="image-20230607183119806"></p><h2 id="2、设计一张老师表">2、设计一张老师表</h2><p>设计一张老师表，包含以下字段：姓名、年龄、身高</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table teachers (name varchar(50),age int ,tall int);</span><br></pre></td></tr></table></figure><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202306091657841.png" alt="image-20230609165701801"></p>]]></content>
    
    
    <summary type="html">初探MySQL：数据库的基本操作</summary>
    
    
    
    <category term="笔记" scheme="https://www.zxhy.club/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="MySQL" scheme="https://www.zxhy.club/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java学习之旅：继承和多态</title>
    <link href="https://www.zxhy.club/posts/java08.html"/>
    <id>https://www.zxhy.club/posts/java08.html</id>
    <published>2023-05-30T09:28:23.000Z</published>
    <updated>2023-05-30T11:15:14.597Z</updated>
    
    <content type="html"><![CDATA[<h1>一、前言</h1><p>在Java的核心概念中，继承和多态无疑是重要的一环。它们都是Java以及其他许多面向对象编程语言的基石，为我们提供了强大的工具来创建模块化，可重用和易于维护的代码。</p><p>继承让我们可以创建新的类，通过继承现有类的属性和方法，来复用代码并添加或覆盖特定的行为。这为我们提供了一种强大的方式来组织和结构化我们的代码，使我们的代码更加易于理解和维护。</p><p>与此同时，多态则提供了一种允许我们将一个类的对象视为其父类或接口的对象的能力。这使我们能够编写出更加通用和灵活的代码，我们的代码可以对各种不同类型的对象执行相同的操作，而无需关心这些对象的具体类型。</p><h1>二、继承</h1><p>Java中使用类对现实世界中实体来进行描述，类经过实例化之后的产物对象，则可以用来表示现实中的实体，但是现实世界错综复杂，事物之间可能会存在一些关联，那在设计程序是就需要考虑。</p><p>看一下，下面的两个类，一个猫类，一个狗类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dog.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(name + <span class="string">&quot;正在吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(name + <span class="string">&quot;正在睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">Bark</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(name + <span class="string">&quot;汪汪汪~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">   System.out.println(name + <span class="string">&quot;正在吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    System.out.println(name + <span class="string">&quot;正在睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">mew</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(name + <span class="string">&quot;喵喵喵~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过观察上述代码会发现，猫和狗的类中存在大量重复，如下所示：</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305100034246.png" alt="image-20230510003440174"></p><p>那能否将这些共性抽取呢？<strong>面向对象思想中提出了继承的概念，专门用来进行共性抽取，实现代码复用</strong>。</p><h2 id="1、继承的概念">1、继承的概念</h2><p><strong>继承(inheritance)机制</strong>：是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行<strong>扩展，增加新功能</strong>，这样产生新的类，称<strong>派生类</strong>。继承呈现了面向对象程序设计的层次结构， 体现了由简单到复杂的认知过程。继承主要解决的问题是：<strong>共性的抽取，实现代码复用</strong>。</p><p>例如：狗和猫都是动物，那么我们就可以将共性的内容进行抽取，然后采用继承的思想来达到共用。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305100042600.png" alt="image-20230510004236552"></p><p>上述图示中，Dog和Cat都继承了Animal类，其中：Animal类称为父类/基类或超类，Dog和Cat可以称为Animal的子类/派生类，继承之后，子类可以复用父类中成员，子类在实现时只需关心自己新增加的成员即可。从继承概念中可以看出继承最大的作用就是：实现代码复用，还有就是来实现多态(后序讲)。</p><h2 id="2、继承的语法">2、继承的语法</h2><p>在Java中如果要表示类之间的继承关系，需要借助<code>extends</code>关键字，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 子类 extends 父类 &#123;</span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对刚刚的场景使用继承方式重新设计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Animal.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    String name; <span class="comment">// 动物的名字</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">// 动物的年龄</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 动物吃饭的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;正在吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动物睡觉的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;正在睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123; <span class="comment">// Dog类继承自Animal类</span></span><br><span class="line">    <span class="comment">// 狗叫的方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;汪汪汪~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cat.Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123; <span class="comment">// Cat类继承自Animal类</span></span><br><span class="line">    <span class="comment">// 猫叫的方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">mew</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;喵喵喵~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestExtend.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestExtend</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dog类中并没有定义任何成员变量，name和age属性肯定是从父类Animal中继承下来的</span></span><br><span class="line">        System.out.println(dog.name);</span><br><span class="line">        System.out.println(dog.age);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dog访问的eat()和sleep()方法也是从Animal中继承下来的</span></span><br><span class="line">        dog.eat();</span><br><span class="line">        dog.sleep();</span><br><span class="line">        dog.bark(); <span class="comment">// 调用Dog类特有的bark方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p>子类会将父类中的成员变量或者成员方法继承到子类中了</p></li><li><p>子类继承父类之后，必须要新添加自己特有的成员，体现出与基类的不同，否则就没有必要继承了</p></li></ul><h2 id="3、父类成员访问">3、父类成员访问</h2><p>在继承体系中，子类将父类中的方法和字段继承下来了，那在子类中能否直接访问父类中继承下来的成员呢？</p><h3 id="Ⅰ、子类中访问父类的成员变量">Ⅰ、子类中访问父类的成员变量</h3><p><strong>子类和父类不存在同名成员变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        a = <span class="number">10</span>; <span class="comment">// 访问从父类中继承下来的a</span></span><br><span class="line">        b = <span class="number">20</span>; <span class="comment">// 访问从父类中继承下来的b</span></span><br><span class="line">        c = <span class="number">30</span>; <span class="comment">// 访问子类自己的c</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>子类和父类成员变量同名</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="type">int</span> a; <span class="comment">// 与父类中成员a同名，且类型相同</span></span><br><span class="line">    <span class="type">char</span> b; <span class="comment">// 与父类中成员b同名，但类型不同</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        a = <span class="number">100</span>; <span class="comment">// 访问父类继承的a，还是子类自己新增的a？</span></span><br><span class="line">        b = <span class="number">101</span>; <span class="comment">// 访问父类继承的b，还是子类自己新增的b?</span></span><br><span class="line">        c = <span class="number">102</span>; <span class="comment">// 子类没有c，访问的肯定是从父类继承下来的c</span></span><br><span class="line">        <span class="comment">// d = 103; // 编译失败，因为父类和子类都没有定义成员变量b</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在子类方法中 或者 通过子类对象访问成员时</strong>：</p><ul><li><p>如果访问的成员变量子类中有，优先访问自己的成员变量。</p></li><li><p>如果访问的成员变量子类中无，则访问父类继承下来的，如果父类也没有定义，则编译报错。</p></li><li><p>如果访问的成员变量与父类中成员变量同名，则优先访问自己的。</p></li></ul><p><strong>成员变量访问遵循就近原则，自己有优先自己的，如果没有则向父类中找</strong>。</p><h3 id="Ⅱ、子类中访问父类的成员方法">Ⅱ、子类中访问父类的成员方法</h3><p><strong>成员方法名字不同</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base中的methodA()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Derived中的methodB()方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodC</span><span class="params">()</span>&#123;</span><br><span class="line">        methodB(); <span class="comment">// 访问子类自己的methodB()</span></span><br><span class="line">        methodA(); <span class="comment">// 访问父类继承的methodA()</span></span><br><span class="line">        <span class="comment">// methodD(); // 编译失败，在整个继承体系中没有发现方法methodD()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：成员方法没有同名时，在子类方法中或者通过子类对象访问方法时，则优先访问自己的，自己没有时再到父类中找，如果父类中也没有则报错。</p><p><strong>成员方法名字相同</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base中的methodA()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base中的methodB()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Derived中的method(int)方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Derived中的methodB()方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodC</span><span class="params">()</span>&#123;</span><br><span class="line">        methodA(); <span class="comment">// 没有传参，访问父类中的methodA()</span></span><br><span class="line">        methodA(<span class="number">20</span>); <span class="comment">// 传递int参数，访问子类中的methodA(int)</span></span><br><span class="line">        methodB(); <span class="comment">// 直接访问，则永远访问到的都是子类中的methodB()，基类的无法访问到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>【说明】</strong></p><ul><li><p>通过子类对象访问父类与子类中不同名方法时，优先在子类中找，找到则访问，否则在父类中找，找到则访问，否则编译报错。</p></li><li><p>通过派生类对象访问父类与子类同名方法时，如果父类和子类同名方法的参数列表不同(重载)，根据调用方法适传递的参数选择合适的方法访问，如果没有则报错。</p></li></ul><p><strong>问题：如果子类中存在与父类中相同的成员时，那如何在子类中访问父类相同名称的成员呢？</strong></p><blockquote><p>在Java中，如果子类中存在与父类中相同名称的成员，那么在子类中默认访问的是子类自己的成员。要在子类中访问父类的同名成员，可以使用<code>super</code>关键字。<code>super</code>关键字用于引用当前子类实例的直接父类。</p></blockquote><h2 id="4、-super关键字">4、 <code>super</code>关键字</h2><p>由于设计不好，或者因场景需要，子类和父类中可能会存在相同名称的成员，如果要在子类方法中访问父类同名成员时，该如何操作？</p><p>直接访问是无法做到的，Java提供了**<code>super</code>关键字，该关键字主要作用：在子类方法中访问父类的成员**。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int</span> a; <span class="comment">// 基类中的成员变量</span></span><br><span class="line">    <span class="type">int</span> b; <span class="comment">// 基类中的成员变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base中的methodA()&quot;</span>); <span class="comment">// 打印表明在基类中的语句</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base中的methodB()&quot;</span>); <span class="comment">// 打印表明在基类中的语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int</span> a; <span class="comment">// 使用相同的名称和类型遮蔽了基类中的成员变量&#x27;a&#x27;</span></span><br><span class="line">    <span class="type">char</span> b; <span class="comment">// 使用相同的名称但不同类型遮蔽了基类中的成员变量&#x27;b&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载了基类中的methodA()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Derived中的method()方法&quot;</span>); <span class="comment">// 打印表明在派生类中的语句</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写了基类中的methodB()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Derived中的methodB()方法&quot;</span>); <span class="comment">// 打印表明在派生类中的语句</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodC</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 对于同名的成员变量，直接访问时，访问的是派生类中的变量</span></span><br><span class="line">        <span class="built_in">this</span>.a = <span class="number">100</span>; <span class="comment">// 等价于：this.a = 100;</span></span><br><span class="line">        <span class="built_in">this</span>.b = <span class="number">101</span>; <span class="comment">// 等价于：this.b = 101;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意：&#x27;this&#x27; 是当前对象的引用</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 要访问基类中的成员变量，需要使用&#x27;super&#x27;关键字</span></span><br><span class="line">        <span class="built_in">super</span>.a = <span class="number">200</span>;</span><br><span class="line">        <span class="built_in">super</span>.b = <span class="number">201</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在基类和派生类中都存在重载的方法，可以通过参数列表区分访问基类还是派生类的方法</span></span><br><span class="line">        methodA(); <span class="comment">// 没有传参，访问基类中的methodA()</span></span><br><span class="line">        methodA(<span class="number">20</span>); <span class="comment">// 传递int参数，访问派生类中的methodA(int)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 要访问重写的基类方法，需要使用&#x27;super&#x27;关键字</span></span><br><span class="line">        methodB(); <span class="comment">// 直接访问，则永远访问派生类中的methodB()，无法访问基类的</span></span><br><span class="line">        <span class="built_in">super</span>.methodB(); <span class="comment">// 访问基类的methodB()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在子类方法中，如果想要明确访问父类中成员时，借助<code>super</code>关键字即可。</p><p>【<strong>注意事项</strong>】</p><ul><li><p>只能在非静态方法中使用。</p></li><li><p>在子类方法中，访问父类的成员变量和方法。</p></li></ul><h2 id="5、子类构造方法">5、子类构造方法</h2><p>父子父子，先有父再有子，即：子类对象构造时，需要先调用基类构造方法，然后执行子类的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base()&quot;</span>); <span class="comment">// 打印在基类构造方法中的语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Derived</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// super(); 注意：子类构造方法中默认会调用基类的无参构造方法：super()</span></span><br><span class="line">        <span class="comment">// 当用户没有显式写出时，编译器会自动添加super()，并且super()必须是子类构造方法中的第一条语句，</span></span><br><span class="line">        <span class="comment">// 并且只能出现一次</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Derived()&quot;</span>); <span class="comment">// 打印在派生类构造方法中的语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Derived</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Derived</span>(); <span class="comment">// 创建派生类的实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果打印：</span><br><span class="line">    Base()</span><br><span class="line">    Derived()</span><br></pre></td></tr></table></figure><p>在子类的构造方法中，如果没有显式地写出关于基类构造的代码，那么在构造子类对象时会先执行基类的构造方法，然后再执行子类的构造方法。这是因为子类对象的成员由两部分组成：继承自基类的部分和子类新增加的部分。因此，在构造子类对象时，需要先调用基类的构造方法来构造继承下来的成员，然后再调用子类自己的构造方法来初始化子类新增加的成员。</p><p>需要注意以下几点：</p><ol><li>如果父类显式地定义了无参或默认的构造方法，那么在子类的构造方法中，默认会隐含地调用<code>super()</code>，即调用基类的构造方法。</li><li>如果父类的构造方法带有参数，那么在子类中就需要显式地定义构造方法，并在子类的构造方法中选择适合的父类构造方法进行调用，否则会导致编译错误。</li><li>在子类的构造方法中，通过<code>super(...)</code>调用父类构造方法时，必须作为子类构造函数中的第一条语句。</li><li><code>super(...)</code>只能在子类的构造方法中出现一次，并且不能与<code>this</code>同时出现。</li></ol><h2 id="6、super和this">6、<code>super</code>和<code>this</code></h2><p><code>super</code>和<code>this</code>都可以在成员方法中用来访问：成员变量和调用其他的成员函数，都可以作为构造方法的第一条语句，那他们之间有什么区别呢？</p><p>【<strong>相同点</strong>】</p><ul><li><p>都是Java中的关键字</p></li><li><p>只能在类的非静态方法中使用，用来访问非静态成员方法和字段</p></li><li><p>在构造方法中调用时，必须是构造方法中的第一条语句，并且不能同时存在</p></li></ul><p>【<strong>不同点</strong>】</p><ul><li><code>this</code>是当前对象的引用，当前对象即调用实例方法的对象，<code>super</code>相当于是子类对象中从父类继承下来部分成员的引用</li></ul><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305111740121.png" alt="image-20230511174010010"></p><ul><li><p>在非静态成员方法中，<code>this</code>用来访问本类的方法和属性，<code>super</code>用来访问父类继承下来的方法和属性</p></li><li><p>在构造方法中：<code>this(...)</code>用于调用本类构造方法，<code>super(...)</code>用于调用父类构造方法，两种调用不能同时在构造方法中出现</p></li><li><p>构造方法中一定会存在<code>super(...)</code>的调用，用户没有写编译器也会增加，但是<code>this(...)</code>用户不写则没有</p></li></ul><h2 id="7、protected-关键字">7、<code>protected</code> <strong>关键字</strong></h2><p>在类和对象中，为了实现封装特性，Java中引入了访问限定符，主要限定：类或者类中成员能否在类外或者其他包中被访问。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305121506108.png" alt="image-20230512150656009"></p><p>那父类中不同访问权限的成员，在子类中的可见性又是什么样子的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extend01包中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;   <span class="comment">// 私有成员，只有类内部可以访问</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> b; <span class="comment">// 受保护的成员，只有类内部、子类和同一包中的类可以访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> c;    <span class="comment">// 公有成员，任何地方都可以访问</span></span><br><span class="line">    <span class="type">int</span> d;           <span class="comment">// 默认访问权限，只有类内部和同一包中的类可以访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// extend01包中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123; <span class="comment">// D是B的子类，属于同一包</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// super.a = 10; // 编译报错，父类private成员在相同包子类中不可见</span></span><br><span class="line">        <span class="built_in">super</span>.b = <span class="number">20</span>; <span class="comment">// 父类中protected成员在相同包子类中可以直接访问</span></span><br><span class="line">        <span class="built_in">super</span>.c = <span class="number">30</span>; <span class="comment">// 父类中public成员在相同包子类中可以直接访问</span></span><br><span class="line">        <span class="built_in">super</span>.d = <span class="number">40</span>; <span class="comment">// 父类中默认访问权限修饰的成员在相同包子类中可以直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// extend02包中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span> &#123; <span class="comment">// C是B的子类，但是属于不同的包</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// super.a = 10; // 编译报错，父类中private成员在不同包子类中不可见</span></span><br><span class="line">        <span class="built_in">super</span>.b = <span class="number">20</span>; <span class="comment">// 父类中protected修饰的成员在不同包子类中可以直接访问</span></span><br><span class="line">        <span class="built_in">super</span>.c = <span class="number">30</span>; <span class="comment">// 父类中public修饰的成员在不同包子类中可以直接访问</span></span><br><span class="line">        <span class="comment">//super.d = 40; // 父类中默认访问权限修饰的成员在不同包子类中不能直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// extend02包中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestC</span> &#123; <span class="comment">// TestC是一个普通类，不是B的子类，也在不同的包中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">        c.method();</span><br><span class="line">        <span class="comment">// System.out.println(c.a); // 编译报错，父类中private成员在不同包其他类中不可见</span></span><br><span class="line">        <span class="comment">// System.out.println(c.b); // 父类中protected成员在不同包其他类中不能直接访问</span></span><br><span class="line">        System.out.println(c.c); <span class="comment">// 父类中public成员在不同包其他类中可以直接访问</span></span><br><span class="line">        <span class="comment">// System.out.println(c.d); // 父类中默认访问权限修饰的成员在不同包其他类中不能直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：父类中<code>private</code>成员变量虽然在子类中不能直接访问，但是也继承到子类中了</p><p><strong>什么时候下用哪一种呢</strong>?</p><blockquote><p>我们希望类要尽量做到 “封装”, 即隐藏内部实现细节, 只暴露出 <strong>必要</strong> 的信息给类的调用者</p><p>因此我们在使用的时候应该尽可能的使用 <strong>比较严格</strong> 的访问权限，例如如果一个方法能用 <code>private</code>, 就尽量不要用 <code>public</code></p><p>另外, 还有一种 <strong>简单粗暴</strong> 的做法: 将所有的字段设为 <code>private</code>, 将所有的方法设为 <code>public</code>不过这种方式属于是对访问权限的滥用, 还是更希望同学们能写代码的时候认真思考, 该类提供的字段方法到底给 “谁” 使用(是类内部自己用, 还是类的调用者使用, 还是子类使用)</p></blockquote><h2 id="8、继承方式">8、继承方式</h2><p>在现实生活中，事物之间的关系是非常复杂，灵活多样，比如：</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305121511637.png" alt="image-20230512151118576"></p><p>但在Java中只支持以下几种继承方式：</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305121511564.png" alt="image-20230512151133518"></p><p>**注意：**Java中不支持多继承。</p><blockquote><p>时刻牢记, 我们写的类是现实事物的抽象. 而我们真正在公司中所遇到的项目往往业务比较复杂, 可能会涉及到一系列复杂的概念, 都需要我们使用代码来表示, 所以我们真实项目中所写的类也会有很多，类之间的关系也会更加复杂。</p><p>但是即使如此, 我们并不希望类之间的继承层次太复杂. <strong>一般我们不希望出现超过三层的继承关系</strong>. 如果继承层次太多, 就需要考虑对代码进行重构了。如果想从语法上进行限制继承, 就可以使用<code>final</code> 关键字</p></blockquote><h2 id="9、final关键字">9、<code>final</code>关键字</h2><p><code>final</code>关键可以用来修饰变量、成员方法以及类。</p><ul><li><strong>修饰变量或字段，表示常量(即不能修改)</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">a = <span class="number">20</span>; <span class="comment">// 编译出错</span></span><br></pre></td></tr></table></figure><ul><li><strong>修饰类：表示此类不能被继承</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译出错</span></span><br><span class="line">Error:(<span class="number">3</span>, <span class="number">27</span>) java: 无法从最终com.bit.Animal进行继</span><br></pre></td></tr></table></figure><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305121515759.png" alt="image-20230512151520650"></p><p>我们平时是用的<code>String</code> 字符串类, 就是用 <code>final</code>修饰的, 不能被继承</p><ul><li><strong>修饰方法：表示该方法不能被重写</strong></li></ul><h2 id="10、继承与组合">10、继承与组合</h2><p>和继承类似, 组合也是一种表达类之间关系的方式, 也是能够达到代码重用的效果。组合并没有涉及到特殊的语法(诸如 <code>extends</code> 这样的关键字), 仅仅是将一个类的实例作为另外一个类的字段。</p><p>组合（或聚合）是另一种关系，表示一个类是由其他类的对象组成的。换句话说，一个类的对象包含了其他类的对象。这种关系通常被描述为&quot;有-a&quot;关系。例如，一辆汽车有一个引擎和四个轮子，因此汽车类可以包含一个引擎对象和四个轮子对象。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305121519032.png" alt="image-20230512151945967"></p><p>组合的主要优点是它提供了更好的封装，更强的代码灵活性，更易于修改和维护。由于类之间的关系不再像继承那样紧密，所以修改一个类的实现不太可能影响到使用该类的其他类。此外，组合也使得代码更加模块化，每个类都专注于一个单一的职责。</p><p>然而，组合也有一些缺点。它可能导致更复杂的代码，因为你需要管理和协调多个对象之间的交互。</p><p>选择使用继承还是组合通常取决于具体的需求和上下文。</p><p>一般来说，如果两个类之间存在&quot;is-a&quot;（是一个）的关系，比如&quot;苹果是一种水果&quot;，那么继承可能是最好的选择。</p><p>如果两个类之间存在&quot;has-a&quot;（有一个）的关系，比如&quot;汽车有一个引擎&quot;，那么组合可能是更好的选择。</p><p><a href="https://www.hollischuang.com/archives/1319">深入理解Java中的组合和继承</a></p><h1>三、多态</h1><h2 id="1、多态的概念">1、多态的概念</h2><p>通俗来说，就是多种形态，<strong>具体点就是去完成某个行为，当不同的对象去完成时会产生出不同的状态。</strong></p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305140833595.png" alt="image-20230514083339505"></p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305140833338.png" alt="image-20230514083348271"></p><p>总的来说：同一件事情，发生在不同对象身上，就会产生不同的结果。</p><h2 id="2、多态实现条件">2、多态实现条件</h2><p>在Java中要实现多态，必须要满足如下几个条件，缺一不可：</p><ul><li><p><strong>必须在继承体系下</strong></p></li><li><p><strong>子类必须要对父类中方法进行重写</strong></p></li><li><p><strong>通过父类的引用调用重写的方法</strong></p></li></ul><p><strong>多态体现：在代码运行时，当传递不同类对象时，会调用对应类中的方法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123; <span class="comment">// 定义动物类</span></span><br><span class="line">  String name; <span class="comment">// 动物名</span></span><br><span class="line">  <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123; <span class="comment">// 构造方法，传入动物名和年龄</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123; <span class="comment">// 动物吃饭方法</span></span><br><span class="line">    System.out.println(name + <span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123; <span class="comment">// 猫类继承于动物类</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123; <span class="comment">// 构造方法，传入猫名和年龄，并调用父类的构造方法</span></span><br><span class="line">    <span class="built_in">super</span>(name, age);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="comment">// 重写父类的吃饭方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">&quot;吃鱼~~~&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123; <span class="comment">// 狗类继承于动物类</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123; <span class="comment">// 构造方法，传入狗名和年龄，并调用父类的构造方法</span></span><br><span class="line">    <span class="built_in">super</span>(name, age);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="comment">// 重写父类的吃饭方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">&quot;吃骨头~~~&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////分割线//////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Animal 类作为父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAnimal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个静态方法,接收 Animal 类型的形参</span></span><br><span class="line">    <span class="comment">// 编译时并不知道形参引用的具体子类对象，只有运行时才知道</span></span><br><span class="line">    <span class="comment">// 形参类型必须是 Animal，因为 Cat 和 Dog 都是 Animal 的子类</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(Animal a)</span>&#123;</span><br><span class="line">    <span class="comment">// 调用 Animal 类中的 eat 方法，此处的 eat 方法被定义为了 abstract，子类必须实现它</span></span><br><span class="line">    <span class="comment">// 编译时使用形参类型，运行时使用具体对象类型</span></span><br><span class="line">    a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 Cat 和 Dog 的实例</span></span><br><span class="line">    <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;元宝&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;小七&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 eat 方法传入 Cat 和 Dog 类型的实例</span></span><br><span class="line">    <span class="comment">// 编译时根据传入的实例类型推断调用哪个 eat 方法，运行时再调用具体的 eat 方法</span></span><br><span class="line">    eat(cat);</span><br><span class="line">    eat(dog);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">    元宝吃鱼~~~</span><br><span class="line">    元宝正在睡觉</span><br><span class="line">    小七吃骨头~~~</span><br><span class="line">    小七正在睡觉</span><br></pre></td></tr></table></figure><p>在上述代码中, 分割线上方的代码是 <strong>类的实现者</strong> 编写的, 分割线下方的代码是 <strong>类的调用者</strong> 编写的。</p><p>当类的调用者在编写 eat 这个方法的时候, 参数类型为 Animal (父类), 此时在该方法内部并不知道, 也不关注当前的a 引用指向的是哪个类型(哪个子类)的实例，此时a这个引用调用 eat方法可能会有多种不同的表现(和a引用的实例相关)，这种行为就称为 多态。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305140839598.png" alt="image-20230514083905513"></p><h2 id="3、重写">3、重写</h2><p>重写(override)：也称为覆盖。重写是子类对父类非静态、非<code>private</code>修饰，非<code>final</code>修饰，非构造方法等的实现过程进行重新编写, <strong>返回值和形参都不能改变</strong>。**即外壳不变，核心重写！**重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p><h3 id="Ⅰ、方法重写的规则">Ⅰ、方法重写的规则</h3><ul><li><p>子类在重写父类的方法时，一般必须与父类方法原型一致： 返回值类型 方法名 (参数列表) 要完全一致</p></li><li><p>被重写的方法返回值类型可以不同，但是必须是具有父子关系的</p></li><li><p>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类方法被<code>public</code>修饰，则子类中重写该方法就不能声明为 <code>protected</code></p></li><li><p>父类被<code>static</code>、<code>private</code>修饰的方法、构造方法都不能被重写。</p></li><li><p>重写的方法, 可以使用 <code>@Override</code> 注解来显式指定. 有了这个注解能帮我们进行一些合法性校验. 例如不小心将方法名字拼写错了 (比如写成 <code>aet</code>), 那么此时编译器就会发现父类中没有 <code>aet</code> 方法, 就会编译报错, 提示无法构成重写</p></li></ul><h3 id="Ⅱ、重写和重载的区别">Ⅱ、重写和重载的区别</h3><table><thead><tr><th style="text-align:center">区别点</th><th style="text-align:center">重写</th><th style="text-align:center">重载</th></tr></thead><tbody><tr><td style="text-align:center">参数列表</td><td style="text-align:center">一定不能修改</td><td style="text-align:center">必须修改</td></tr><tr><td style="text-align:center">返回类型</td><td style="text-align:center">一定不能修改【除非可以构成父子类关系】</td><td style="text-align:center">可以修改</td></tr><tr><td style="text-align:center">访问限定符</td><td style="text-align:center">一定不能做更严格的限制（可以降低限制）</td><td style="text-align:center">可以修改</td></tr></tbody></table><p><strong>方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</strong></p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305301855925.png" alt="image-20230530185556823"></p><h3 id="Ⅲ、重写的设计原则">Ⅲ、重写的设计原则</h3><p>对于已经投入使用的类，尽量不要进行修改。最好的方式是：重新定义一个新的类，来重复利用其中共性的内容，并且添加或者改动新的内容。</p><p>例如：若干年前的手机，只能打电话，发短信，来电显示只能显示号码，而今天的手机在来电显示的时候，不仅仅可以显示号码，还可以显示头像，地区等。在这个过程当中，我们<strong>不应该在原来老的类上进行修改，因为原来的类，可能还在有用户使用</strong>，正确做法是：<strong>新建一个新手机的类，对来电显示这个方法重写就好了，这样就达到了我们当今的需求了</strong>。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305301857145.png" alt="image-20230530185732089"></p><p><strong>静态绑定</strong>：也称为前期绑定(早绑定)，即在编译时，根据用户所传递实参类型就确定了具体调用那个方法。典型代表函数重载</p><p><strong>动态绑定</strong>：也称为后期绑定(晚绑定)，即在编译时，不能确定方法的行为，需要等到程序运行时，才能够确定具体调用那个类的方法</p><h2 id="4、向上转移和向下转型">4、向上转移和向下转型</h2><h3 id="Ⅰ、向上转型">Ⅰ、向上转型</h3><p>向上转型：实际就是创建一个子类对象，将其当成父类对象来使用。</p><p>语法格式：父类类型 对象名 = new 子类类型()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;元宝&quot;</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>animal是父类类型，但可以引用一个子类对象，因为是从小范围向大范围的转换。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305301859073.png" alt="image-20230530185924004"></p><p><strong>使用场景：直接赋值、方法传参、方法返回</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAnimal</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 方法传参：形参为父类型引用，可以接收任意子类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">eatFood</span><span class="params">(Animal a)</span>&#123;</span><br><span class="line">    a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 作返回值：返回任意子类对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title function_">buyAnimal</span><span class="params">(String <span class="keyword">var</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;狗&quot;</span>.equals(<span class="keyword">var</span>) )&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;狗狗&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;猫&quot;</span> .equals(<span class="keyword">var</span>))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;猫猫&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;元宝&quot;</span>,<span class="number">2</span>); <span class="comment">// 1. 直接赋值：子类对象赋值给父类对象</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;小七&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        eatFood(cat);</span><br><span class="line">        eatFood(dog);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> buyAnimal(<span class="string">&quot;狗&quot;</span>);</span><br><span class="line">        animal.eat();</span><br><span class="line">        </span><br><span class="line">        animal = buyAnimal(<span class="string">&quot;猫&quot;</span>);</span><br><span class="line">        animal.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>向上转型的优点：让代码实现更简单灵活。</strong></p><p><strong>向上转型的缺陷：不能调用到子类特有的方法。</strong></p><h3 id="Ⅱ、向下转型">Ⅱ、向下转型</h3><p>将一个子类对象经过向上转型之后当成父类方法使用，再无法调用子类的方法，但有时候可能需要调用子类特有的方法，此时：将父类引用再还原为子类对象即可，即向下转换。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305301902990.png" alt="image-20230530190203937"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAnimal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;元宝&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;小七&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 向上转型</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> cat;</span><br><span class="line">        animal.eat();</span><br><span class="line">        animal = dog;</span><br><span class="line">        animal.eat();</span><br><span class="line">        <span class="comment">// 编译失败，编译时编译器将animal当成Animal对象处理</span></span><br><span class="line">        <span class="comment">// 而Animal类中没有bark方法，因此编译失败</span></span><br><span class="line">        <span class="comment">// animal.bark();</span></span><br><span class="line">        <span class="comment">// 向上转型</span></span><br><span class="line">        <span class="comment">// 程序可以通过编程，但运行时抛出异常---因为：animal实际指向的是狗</span></span><br><span class="line">        <span class="comment">// 现在要强制还原为猫，无法正常还原，运行时抛出：ClassCastException</span></span><br><span class="line">        cat = (Cat)animal;</span><br><span class="line">        cat.mew();</span><br><span class="line">        <span class="comment">// animal本来指向的就是狗，因此将animal还原为狗也是安全的</span></span><br><span class="line">        dog = (Dog)animal;</span><br><span class="line">        dog.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向下转型用的比较少，而且不安全，万一转换失败，运行时就会抛异常。Java中为了提高向下转型的安全性，引入了 <code>instanceof </code>，如果该表达式为<code>true</code>，则可以安全转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAnimal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;元宝&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;小七&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 向上转型</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> cat;</span><br><span class="line">        animal.eat();</span><br><span class="line">        animal = dog;</span><br><span class="line">        animal.eat();</span><br><span class="line">        <span class="keyword">if</span>(animal <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">            cat = (Cat)animal;</span><br><span class="line">            cat.mew();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(animal <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">            dog = (Dog)animal;</span><br><span class="line">            dog.bark();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、多态的优缺点">5、多态的优缺点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="comment">//属性....</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;画图形！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rect</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;♦&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cycle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;●&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flower</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;❀&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ⅰ、优点">Ⅰ、优点</h3><p><strong>能够降低代码的 “圈复杂度” 避免使用大量的 if - else</strong></p><blockquote><p>什么叫 “圈复杂度” ?</p><p>圈复杂度是一种描述一段代码复杂程度的方式。 一段代码如果平铺直叙, 那么就比较简单容易理解。而如果有很多的条件分支或者循环语句, 就认为理解起来更复杂，因此我们可以简单粗暴的计算一段代码中条件语句和循环语句出现的个数, 这个个数就称为 “圈复杂度”.如果一个方法的圈复杂度太高, 就需要考虑重构，不同公司对于代码的圈复杂度的规范不一样，一般不会超过 10</p></blockquote><p>例如我们现在需要打印的不是一个形状了, 而是多个形状. 如果不基于多态, 实现代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">drawShapes</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Rect</span> <span class="variable">rect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rect</span>();</span><br><span class="line">    <span class="type">Cycle</span> <span class="variable">cycle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cycle</span>();</span><br><span class="line">    <span class="type">Flower</span> <span class="variable">flower</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Flower</span>();</span><br><span class="line">    String[] shapes = &#123;<span class="string">&quot;cycle&quot;</span>, <span class="string">&quot;rect&quot;</span>, <span class="string">&quot;cycle&quot;</span>, <span class="string">&quot;rect&quot;</span>, <span class="string">&quot;flower&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (String shape : shapes) &#123;</span><br><span class="line">    <span class="keyword">if</span> (shape.equals(<span class="string">&quot;cycle&quot;</span>)) &#123;</span><br><span class="line">    cycle.draw();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shape.equals(<span class="string">&quot;rect&quot;</span>)) &#123;</span><br><span class="line">    rect.draw();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shape.equals(<span class="string">&quot;flower&quot;</span>)) &#123;</span><br><span class="line">   flower.draw();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用使用多态, 则不必写这么多的 if - else 分支语句, 代码更简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">drawShapes</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 我们创建了一个 Shape 对象的数组.</span></span><br><span class="line">    Shape[] shapes = &#123;<span class="keyword">new</span> <span class="title class_">Cycle</span>(), <span class="keyword">new</span> <span class="title class_">Rect</span>(), <span class="keyword">new</span> <span class="title class_">Cycle</span>(),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Rect</span>(), <span class="keyword">new</span> <span class="title class_">Flower</span>()&#125;;</span><br><span class="line"><span class="keyword">for</span> (Shape shape : shapes) &#123;</span><br><span class="line">shape.draw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可扩展能力更强</strong></p><p>如果要新增一种新的形状, 使用多态的方式代码改动成本也比较低</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;△&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于类的调用者来说(drawShapes方法), 只要创建一个新类的实例就可以了, 改动成本很低，而对于不用多态的情况, 就要把 drawShapes 中的 if - else 进行一定的修改, 改动成本更高。</p><h3 id="Ⅱ、缺点">Ⅱ、缺点</h3><p><strong>代码的运行效率降低</strong>。</p><blockquote><ul><li>属性没有多态性</li></ul><p>当父类和子类都有同名属性的时候，通过父类引用，只能引用父类自己的成员属性</p><ul><li>构造方法没有多态性</li></ul></blockquote>]]></content>
    
    
    <summary type="html">JavaSE：继承和多态，面向对象编程的深化</summary>
    
    
    
    <category term="笔记" scheme="https://www.zxhy.club/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://www.zxhy.club/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>递归算法：数学归纳法在编程中的应用</title>
    <link href="https://www.zxhy.club/posts/recursion.html"/>
    <id>https://www.zxhy.club/posts/recursion.html</id>
    <published>2023-05-27T14:38:20.000Z</published>
    <updated>2023-05-27T14:39:39.529Z</updated>
    
    <content type="html"><![CDATA[<h1>一、前言</h1><p>嵌套是指在一个事物中包含另一个事物，而递归是一种特殊形式的嵌套，其中一个事物包含自身。</p><p>递归就是一种嵌套的形式，递归函数解决问题时嵌套调用自身。递归的核心思想是通过反复应用相同的过程来解决问题，每一次调用都在规模上比上一次调用更小，直到达到基本情况从而终止递归。<br>递归是一种强大而优雅的技术，它能够将复杂的问题分解成更小的子问题来解决，递归和数学归纳法有密切的关系，递归可以被看作是数学归纳法在编程中的一种具体应用。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305272154262.png" alt="image-20230527215455200"></p><h1>二、递归初步理解</h1><p><strong>递归  = 递推 + 回归</strong></p><p>递归是指函数直接或间接地调用自身的过程。递归函数通常在满足基本条件时停止调用自身，从而避免无限循环。递归的思想是将一个大问题分解成一个或多个相同的较小问题，直到问题简化到可以直接解决为止。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305272202420.png" alt="image-20230527220203369"></p><h2 id="1、数学归纳法">1、数学归纳法</h2><p>数学归纳法的核心思想是：如果一个性质对于某个数成立，而且可以证明如果对于任何数n该性质成立就能推导出对于n+1也成立，那么这个性质就对所有正整数成立。</p><p>数学归纳法主要包括两个步骤：</p><ol><li>基础步骤：首先要证明该性质对于初值（通常是1或0）成立。</li><li>归纳步骤：然后要假设性质对于某个数n成立（这被称为归纳假设），并证明这个假设就能推导出该性质对于n+1也成立。</li></ol><p>我们可以看如下一个数学归纳法的例子，<br>$$<br>用数学归纳法证明：\sum_{i=1}^{n} i = \frac{n*(n + 1)}{2}。<br>$$<br>用数学归纳法来证明：</p><ul><li>先证明对于N=1成立。</li><li>再证明N&gt;1时：假设对于N-1成立，那么对于N成立。</li></ul><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305231702078.png" alt=""></p><h2 id="2、递归的设计">2、递归的设计</h2><p>将上面这个数学归纳法的问题，设计为递归解决，应该怎么解决呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//边界条件：n==1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> sum(n<span class="number">-1</span>)+n;<span class="comment">//利用sum(n-1)的值，计算sum(n)的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用代码解决上面这个问题的时候，我们首先是实现了<strong>边界条件</strong>，这个对于的不就是数学归纳法中证明N=1的时候成立嘛？</p><p>其次，<code> return sum(n-1)+n;</code>这段代码的底层逻辑是假设该递归函数调用的返回值是正确的，而这个假设，就是对应了数学归纳法中的归纳步骤。</p><blockquote><p>在数学归纳法中，我们证明了性质对于一个初始值（通常是1或0）成立。在递归中，我们则定义了一个或多个基本情况，这些情况可以直接解决，无需递归。数学归纳法的归纳步骤和递归的递归步骤都是解决过程的主体部分。在数学归纳法中，我们假设性质对于某个值n成立，然后证明该性质对于n+1也成立。在递归中，假设我们能够解决比当前问题更小的问题，然后通过这些更小的问题来解决当前的问题。</p></blockquote><p>我们可以简单的总结一下递归函数的设计方法：</p><ol><li><strong>确定递归函数的参数和返回值</strong>：首先，你需要明确递归函数的输入（参数）和输出（返回值）是什么。</li><li><strong>确定边界情况</strong>：边界情况是递归函数的终止条件。你需要明确当参数满足什么条件时，函数可以直接返回结果，而无需进一步递归。</li><li><strong>确定递归情况</strong>：递归情况是函数如何调用自身的部分。在这一步，你需要考虑如何将大问题分解成小问题，然后用递归的方式解决这些小问题。</li></ol><h2 id="3、递归的练习">3、递归的练习</h2><h3 id="Ⅰ、路飞吃桃">Ⅰ、路飞吃桃</h3><p>题目链接：<a href="https://oj.haizeix.com/problem/184">路飞吃桃</a></p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305231734265.png" alt=""></p><p>当我们使用递归解决这个问题时，我们可以从第n天开始反向计算。</p><ol><li><strong>边界情况</strong>：因为题目中已经说明了到第n天时只剩下一个桃子，所以在n=1时，桃子的数量为1。</li><li><strong>递归情况</strong>：对于第n天，桃子的数量可以根据第n+1天的数量计算。在第n天，桃子的数量是(第n+1天的桃子数量 + 1) * 2。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span> <span class="params">(<span class="type">int</span> n )</span>  <span class="comment">// 确定递归函数的参数和返回值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)<span class="comment">//确定边界情况</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"><span class="keyword">else</span><span class="comment">//确定递归情况</span></span><br><span class="line"><span class="keyword">return</span> (f(n<span class="number">-1</span>)+<span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f(n));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ⅱ、弹簧版">Ⅱ、弹簧版</h3><p>题目链接：<a href="https://oj.haizeix.com/problem/186">弹簧板 </a></p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305231745031.png" alt=""></p><ol><li><strong>确定递归函数的参数和返回值</strong>：递归函数需要接受弹簧板的跳跃能力列表、当前弹簧板的索引和弹簧板的总数作为参数，并返回小球弹跳出去的总次数。</li><li><strong>确定基本情况</strong>：我们首先需要确定基本情况，即递归函数的终止条件。在这个问题中，如果当前弹簧板超出了弹簧板范围（即当前弹簧板的索引大于等于弹簧板的总数），那么小球无法再继续弹跳，返回0次弹跳。</li><li><strong>确定递归情况</strong>：在递归情况中，我们将计算从当前弹簧板弹跳出去的总次数。根据题目的描述，我们可以通过当前弹簧板的索引和弹簧板的跳跃能力列表来计算下一次弹跳的弹簧板索引。然后，递归调用函数，并返回1加上从下一个弹簧板开始弹跳出去的总次数。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">countBounces</span><span class="params">(<span class="type">int</span> springs[], <span class="type">int</span> currentSpring, <span class="type">int</span> numSprings)</span> &#123;</span><br><span class="line">    <span class="comment">// 边界情况：如果当前弹簧板超出范围，返回0次弹跳</span></span><br><span class="line">    <span class="keyword">if</span> (currentSpring &gt;= numSprings) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归情况：计算从当前弹簧板弹跳出去的次数</span></span><br><span class="line">    <span class="type">int</span> nextSpring = currentSpring + springs[currentSpring];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countBounces(springs, nextSpring, numSprings);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> numSprings;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;numSprings);</span><br><span class="line">    <span class="type">int</span> springs[numSprings];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numSprings; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;springs[i]);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="type">int</span> startSpring = <span class="number">0</span>;  <span class="comment">// 从1号弹簧板开始</span></span><br><span class="line">    <span class="type">int</span> totalBounces = countBounces(springs, startSpring, numSprings);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, totalBounces);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ⅲ、反转链表">Ⅲ、反转链表</h3><p>题目链接：<a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a></p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305231759474.png" alt=""></p><p><strong>【常规解法】</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode new_head,*p = head,*q;</span><br><span class="line">new_head.next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = new_head.next;</span><br><span class="line">            new_head.next = p;</span><br><span class="line">p=q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> new_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>【递归解法】</strong></p><p><strong>边界情况</strong>：如果 <code>head == NULL</code> 或者 <code>head-&gt;next == NULL</code>，这表示链表为空或者链表只有一个节点，无需反转，直接返回 <code>head</code>。</p><p><strong>递归步骤</strong>：如果链表有多个节点，那么首先通过调用 <code>reverseList(head-&gt;next)</code> 进行递归，这个调用会返回反转后的链表头节点（记作 <code>ret</code>）。需要注意的是，此时 <code>head-&gt;next</code> 还是指向原链表的下一个节点，这个节点在反转后的链表中是最后一个节点。然后执行 <code>head-&gt;next-&gt;next = head</code>，这会让 <code>head</code> 的下一个节点的 <code>next</code> 指针指向 <code>head</code>，即实现了局部的反转。最后执行 <code>head-&gt;next = NULL</code>，断开原 <code>head</code> 和 <code>head-&gt;next</code> 之间的链接，这是因为 <code>head</code> 在反转后的链表中应当是最后一个节点，所以 <code>head-&gt;next</code> 应当指向 <code>NULL</code>。最后返回 <code>ret</code>，即反转后的链表的头节点。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305272049320.gif" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ret = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>三、递归的深层理解</h1><h2 id="1、栈帧结构">1、栈帧结构</h2><p>递归允许一个函数直接或间接地调用自己，这种调用方式表现为一种层次结构：每次递归调用都会创建一个新的函数实例，这个新的函数实例处理问题的一部分，并可能进一步调用自身。从底层来看，当一个函数调用自身时，操作系统会为这次函数调用分配一段内存，这段内存称为栈帧。</p><blockquote><p>帧是指为一个函数调用单独分配的那部分栈空间。</p><p>比如，当运行中的程序调用另一个函数时，就要进入一个新的栈帧，原来函数的栈帧称为调用者的帧，新的栈帧称为当前帧。被调用的函数运行结束后当前帧全部收缩，回到调用者的帧。</p></blockquote><p>栈帧的创建和销毁是通过栈指针来实现的。栈指针指向当前栈帧的顶部，当一个新的函数调用发生时，栈指针会向下移动，为新的栈帧腾出空间。而当函数执行完毕后，栈指针会向上移动，销毁当前的栈帧。栈帧结构的使用使得函数调用和返回过程可以按照嵌套的方式进行，每个函数都有自己的独立空间来保存参数、局部变量等信息，从而实现了程序的模块化和递归调用。</p><blockquote><p><code>%ebp</code>是帧指针，它总是指向当前帧的底部；</p><p><code>%esp</code>是栈指针，它总是指向当前帧的顶部。</p></blockquote><p><img src="https://pic3.zhimg.com/80/v2-869540b280be6f354556c41dc28c4d56_1440w.webp" alt="img"></p><h2 id="2、递归与栈">2、递归与栈</h2><p><strong>递归的底层机制是栈。</strong></p><p>这是因为栈在计算机中用于管理函数调用和返回的过程。当一个函数被调用时，会创建一个新的栈帧，栈帧用于存储函数的局部变量、参数和其他相关信息。这个新的栈帧用于存储递归调用的函数的局部变量和参数。每个递归调用都会在调用栈中创建一个新的栈帧，形成一种嵌套的结构。这样，调用栈就能够记录递归调用的顺序和相关的上下文信息。递归的终止条件决定了递归的结束点。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305272136329.png" alt="image-20230527213624249"></p>]]></content>
    
    
    <summary type="html">递归之谜：解析无限嵌套的数学之美</summary>
    
    
    
    <category term="笔记" scheme="https://www.zxhy.club/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="算法" scheme="https://www.zxhy.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java学习之旅：数组</title>
    <link href="https://www.zxhy.club/posts/java06.html"/>
    <id>https://www.zxhy.club/posts/java06.html</id>
    <published>2023-05-25T07:18:34.000Z</published>
    <updated>2023-07-04T01:47:39.863Z</updated>
    
    <content type="html"><![CDATA[<h1>一、前言</h1><p>数组，一种最基础的数据结构。</p><h1>二、数组的基本概念</h1><h2 id="1、什么是数组">1、什么是数组</h2><p>数组：可以看成是<strong>相同类型元素的一个集合</strong>。在内存中是一段连续的空间。比如现实中的车库：</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202306301117149.png" alt="image-20230630111739071"></p><p>在java中，包含6个整形类型元素的数组，就相当于上图中连在一起的6个车位，从上图中可以看到：</p><ul><li><p>数组中存放的元素其类型相同</p></li><li><p>数组的空间是连在一起的</p></li><li><p>每个空间有自己的编号，其实位置的编号为0，即数组的下标。</p></li></ul><h2 id="2、数组的创建">2、数组的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T[] 数组名 = <span class="keyword">new</span> <span class="title class_">T</span>[N];</span><br></pre></td></tr></table></figure><p>T：表示数组中存放元素的类型</p><p>T[]：表示数组的类型</p><p>N：表示数组的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>]; <span class="comment">// 创建一个可以容纳10个int类型元素的数组</span></span><br><span class="line"><span class="type">double</span>[] array2 = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">5</span>];<span class="comment">// 创建一个可以容纳5个double类型元素的数组</span></span><br><span class="line">String[] array3 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>];<span class="comment">// 创建一个可以容纳3个字符串元素的数组</span></span><br></pre></td></tr></table></figure><h2 id="3、数组的初始化">3、数组的初始化</h2><p>数组的初始化主要分为<strong>动态初始化以及静态初始化</strong>。</p><h3 id="Ⅰ、动态初始化">Ⅰ、动态初始化</h3><p><strong>动态初始化：在创建数组时，直接指定数组中元素的个数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>此时，没有给数组赋值，所以开辟的数组空间中的初始值全部为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">           System.out.println(array[i]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202306301133378.png" alt="image-20230630113314320"></p><h3 id="Ⅱ、静态初始化">Ⅱ、静态初始化</h3><p><strong>静态初始化：在创建数组时不直接指定数据元素个数，而直接将具体的数据内容进行指定</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T[] 数组名称 = &#123;data1, data2, data3, ..., datan&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">double</span>[] array2 = <span class="keyword">new</span> <span class="title class_">double</span>[]&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>&#125;;</span><br><span class="line">String[] array3 = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;hell&quot;</span>, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;!!!&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>【注意事项】</strong></p><ul><li><p>静态初始化虽然没有指定数组的长度，编译器在编译时会根据{}中元素个数来确定数组的长度。</p></li><li><p>静态初始化时, {}中数据类型必须与[]前数据类型一致。</p></li><li><p>静态初始化可以简写，省去后面的new T[]。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：虽然省去了new T[], 但是编译器编译代码时还是会还原</span></span><br><span class="line"><span class="type">int</span>[] array1 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">double</span>[] array2 = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>&#125;;</span><br><span class="line">String[] array3 = &#123;<span class="string">&quot;hell&quot;</span>, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;!!!&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>静态和动态初始化也可以分为两步，但是省略格式不可以。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array1;</span><br><span class="line">array1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span>[] array2;</span><br><span class="line">array2 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"><span class="comment">// 注意省略格式不可以拆分, 否则编译失败</span></span><br><span class="line"><span class="comment">// int[] array3;</span></span><br><span class="line"><span class="comment">// array3 = &#123;1, 2, 3&#125;;</span></span><br></pre></td></tr></table></figure><ul><li>如果没有对数组进行初始化，数组中元素有其默认值</li></ul><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">默认值</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">0.0f</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">0.0</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">/u0000</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">false</td></tr></tbody></table><ul><li>如果数组中存储元素类型为引用类型，默认值为null</li></ul><h2 id="4、数组的使用">4、数组的使用</h2><h3 id="Ⅰ、数组中元素的访问">Ⅰ、数组中元素的访问</h3><p><strong>数组在内存中是一段连续的空间，空间的编号都是从0开始的，依次递增，该编号称为数组的下标，数组可以通过下标访问其任意位置的元素</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[]array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);</span><br><span class="line">System.out.println(array[<span class="number">1</span>]);</span><br><span class="line">System.out.println(array[<span class="number">2</span>]);</span><br><span class="line">System.out.println(array[<span class="number">3</span>]);</span><br><span class="line">System.out.println(array[<span class="number">4</span>]);</span><br><span class="line"><span class="comment">// 也可以通过[]对数组中的元素进行修改</span></span><br><span class="line">array[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>【<strong>注意事项</strong>】</p><ul><li><p>数组是一段连续的内存空间，因此<strong>支持随机访问，即通过下标访问快速访问数组中任意位置的元素</strong></p></li><li><p>下标从0开始，介于[0, N）之间不包含N，N为元素个数，不能越界，否则会报出下标越界异常</p></li></ul><h3 id="Ⅱ、遍历数组">Ⅱ、遍历数组</h3><p><strong>&quot;遍历&quot;是指将数组中的所有元素都访问一遍,访问是指对数组中的元素进行某种操作</strong>，比如：打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[]array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    System.out.println(array[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(array[<span class="number">1</span>]);</span><br><span class="line">    System.out.println(array[<span class="number">2</span>]);</span><br><span class="line">    System.out.println(array[<span class="number">3</span>]);</span><br><span class="line">    System.out.println(array[<span class="number">4</span>]);</span><br></pre></td></tr></table></figure><p>上述代码可以起到对数组中元素遍历的目的，但问题是：</p><p>​1.如果数组中增加了一个元素，就需要增加一条打印语句。</p><p>​2.如果输入中有100个元素，就需要写100个打印语句。</p><p>​3.如果现在要把打印修改为给数组中每个元素加1，修改起来非常麻烦。</p><p>通过观察代码可以发现，对数组中每个元素的操作都是相同的，则可以使用循环来进行打印</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[]array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">System.out.println(array[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改成循环之后，上述三个缺陷可以全部2和3问题可以全部解决，但是无法解决问题1。那能否获取到数组的长度呢？</p><p><strong>【注意】在数组中可以通过</strong> <strong>数组对象.length 来获取数组的长度</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[]array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">System.out.println(array[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用<code>for-each</code> 遍历数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x : array) &#123;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>for-each</code>循环（也被称为&quot;增强型for循环）是一种简化迭代集合（如数组、<code>List</code>、<code>Set</code>等）</p><p><code>for-each</code>循环提供了一种更简洁、易读的方式来遍历集合元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Type Name : collection) &#123;</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Type：表示集合中元素的类型。</span></span><br><span class="line"><span class="comment">//Name：是一个临时变量，用于在每次迭代中存储集合中的当前元素。</span></span><br><span class="line"><span class="comment">//collection：要遍历的集合。</span></span><br></pre></td></tr></table></figure></blockquote><h1>三、数组是引用类型</h1><h2 id="1、初试JVM的内存分布">1、初试JVM的内存分布</h2><p>内存是一段连续的存储空间，主要用来存储程序运行时数据的。</p><ul><li><p>程序运行时代码需要加载到内存</p></li><li><p>程序运行产生的中间数据要存放在内存</p></li><li><p>程序中的常量也要保存</p></li><li><p>有些数据可能需要长时间存储，而有些数据当方法运行结束后就要被销毁</p></li></ul><p>如果对内存中存储的数据不加区分的随意存储，那对内存管理起来将会非常麻烦。因此JVM也对所使用的内存按照功能的不同进行了划分：</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202306301156367.png" alt="image-20230630115630312"></p><p><strong>程序计数器 (PC Register)</strong>: 只是一个很小的空间, <strong>保存下一条执行的指令的地址</strong></p><p><strong>虚拟机栈(JVM Stack)</strong>: 与方法调用相关的一些信息，<strong>每个方法在执行时，都会先创建一个栈帧</strong>，栈帧中包含有：<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>返回地址</strong>以及其他的一些信息，保存的都是与方法执行时相关的一些信息。比如：局部变量。<strong>当方法运行结束后，栈帧就被销毁了，即栈帧中保存的数据也被销毁了</strong>。</p><p><strong>本地方法栈(Native Method Stack)</strong>: 本地方法栈与虚拟机栈的作用类似. 只不过<strong>保存的内容是Native方法的局部变量</strong>. 在有些版本的 JVM 实现中(例如HotSpot), 本地方法栈和虚拟机栈是一起的。</p><p><strong>堆(Heap)</strong>: JVM所管理的最大内存区域。<strong>使用new创建的对象都是在堆上保存堆是随着程序开始运行时而创建，随着程序的退出而销毁，堆中的数据只要还有在使用，就不会被销毁。</strong></p><p><strong>方法区(Method Area)</strong>: 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法编译出的的字节码就是保存在这个区域。</p><h2 id="2、基本类型与引用类型的区别">2、基本类型与引用类型的区别</h2><p>基本数据类型创建的变量，称为基本变量，该变量空间中直接存放的是其所对应的值。</p><p>引用数据类型创建的变量，一般称为对象的引用，其空间中存储的是对象所在空间的地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，a、b、arr，都是函数内部的变量，因此其空间都在main方法对应的栈帧中分配。</p><p>a、b是内置类型的变量，因此其空间中保存的就是给该变量初始化的值。</p><p>array是数组类型的引用变量，其内部保存的内容可以简单理解成是数组在堆空间中的首地址。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202306301604584.png" alt="image-20230630160458524"></p><p>从上图可以看到，<strong>引用变量并不直接存储对象本身，可以简单理解成存储的是对象在堆中空间的起始地址。通过该地址，引用变量便可以去操作对象</strong>。</p><p>这个有点类似C语言中的指针，但是Java中引用要比指针的操作更简单。</p><h2 id="3、引用变量">3、引用变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">    array1[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    array1[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">    array1[<span class="number">2</span>] = <span class="number">30</span>;</span><br><span class="line">    <span class="type">int</span>[] array2 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    array2[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">    array2[<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line">    array1 = array2;</span><br><span class="line">    array1[<span class="number">2</span>] = <span class="number">300</span>;</span><br><span class="line">    array1[<span class="number">3</span>] = <span class="number">400</span>;</span><br><span class="line">    array2[<span class="number">4</span>] = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array2.length; i++) &#123;</span><br><span class="line">System.out.println(array2[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202306301610017.png" alt="image-20230630161029934"></p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202306301610177.png" alt="image-20230630161036099">引用变量其实就是一个变量，不过他存储的是一个对象的内存地址。</p><h2 id="4、认识null">4、认识null</h2><p>null 在 Java 中表示 “空引用” , 也就是一个不指向对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="literal">null</span>;</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException</span><br><span class="line">at Test.main(Test.java:<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>null 的作用类似于 C 语言中的 NULL (空指针), 都是表示一个无效的内存位置。因此不能对这个内存进行任何读写操作。一旦尝试读写, 就会抛出<code>NullPointerException</code>。</p><p><strong>注意: Java 中并没有约定 null 和 0 号地址的内存有任何关联</strong></p><h1>四、数组的应用</h1><h2 id="1、保存数据">1、保存数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; ++i)&#123;</span><br><span class="line">    System.out.println(array[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、作为函数的参数">2、作为函数的参数</h2><h3 id="Ⅰ、参数传数组类型">Ⅰ、参数传数组类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[] array)</span>&#123;</span><br><span class="line">       array[<span class="number">0</span>] = <span class="number">8</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">           System.out.print(array[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       <span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">       print(array);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>发现在print方法内部修改数组的内容, 方法外部的数组内容也发生改变。因为数组是引用类型，按照引用类型来进行传递，是可以修改其中存放的内容的。</p><p>**总结: 所谓的 “引用” 本质上只是存了一个地址。**Java 将数组设定成引用类型, 这样的话后续进行数组参数传参, 其实只是将数组的地址传入到函数形参中。这样可以避免对整个数组的拷贝(数组可能比较长, 那么拷贝开销就会很大)</p><h3 id="Ⅱ、作函数的返回值">Ⅱ、作函数的返回值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] func()&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">111</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">222</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;a,b&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] array = func();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        System.out.print(array[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：写一个方法<code>myToString</code>，传入一个数组的时候以字符串的方式进行打印</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">myToString</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(array==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        s+=array[i];</span><br><span class="line">        <span class="keyword">if</span>(i!= array.length-<span class="number">1</span>)</span><br><span class="line">            s+=<span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s+=<span class="string">&quot;]&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] array2 = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> myToString(array);</span><br><span class="line">    <span class="type">String</span> <span class="variable">ret2</span> <span class="operator">=</span> myToString(array2);</span><br><span class="line">    System.out.println(ret);</span><br><span class="line">    System.out.println(ret2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>五、二维数组</h1><p>二维数组本质上也就是一维数组, 只不过每个元素又是一个一维数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[][] 数组名称 = <span class="keyword">new</span> 数据类型 [行数][列数] &#123; 初始化数据 &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = &#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">&#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; arr.length; row++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; arr[row].length; col++) &#123;</span><br><span class="line">System.out.printf(<span class="string">&quot;%d\t&quot;</span>, arr[row][col]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span></span><br></pre></td></tr></table></figure><p>二维数组的用法和一维数组并没有明显差别。</p><p>同理, 还存在 “三维数组”, “四维数组” 等更复杂的数组, 只不过出现频率都很低。</p><h1>六、数组练习</h1><h2 id="1、求数组元素的平均值">1、求数组元素的平均值</h2><p>题目：给定一个整型数组, 求平均值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">ave</span><span class="params">(<span class="type">int</span> [] array)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        sum+=array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)sum /(<span class="type">double</span>)array.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">double</span> <span class="variable">ret</span> <span class="operator">=</span> ave(array);</span><br><span class="line">    System.out.println(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、查找数组中的指定元素">2、查找数组中的指定元素</h2><p>给定一个数组, 再给定一个元素, 找出该元素在数组中的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span> <span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i]==n)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> find(array,<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;下标为：&quot;</span>+ ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、二分查找">3、二分查找</h2><p>针对<strong>有序数组</strong>, 可以使用更高效的二分查找</p><p>以升序数组为例, 二分查找的思路是先取中间位置的元素, 然后使用待查找元素与数组中间元素进行比较：</p><ul><li><p>如果相等，即找到了返回该元素在数组中的下标</p></li><li><p>如果小于，以类似方式到数组左半侧查找</p></li><li><p>如果大于，以类似方式到数组右半侧查找</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binSearch</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (val &gt; array[mid]) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; array[mid]) &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    System.out.println(binSearch(array,<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java自带的也有二分查找，可以直接使用。</p><blockquote><p><code>Arrays.binarySearch</code>方法是Java中的<code>java.util.Arrays</code>类提供的一个实用方法，用于在<strong>已排序</strong>的数组中搜索指定元素。</p><p><code>Arrays.binarySearch</code>有许多重载版本，可以处理不同类型的数组，如<code>int[]</code>、<code>long[]</code>、<code>float[]</code>、<code>double[]</code>、<code>short[]</code>、<code>char[]</code>、<code>byte[]</code>和<code>Object[]</code>等。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> Arrays.binarySearch(array,<span class="number">3</span>);</span><br><span class="line">    System.out.println(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、冒泡排序">4、冒泡排序</h2><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢&quot;浮&quot;到数列的顶端。</p><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202307031056767.gif" alt="bubbleSort"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; arr.length-i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j-<span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[j - <span class="number">1</span>];</span><br><span class="line">                    arr[j - <span class="number">1</span>] = arr[j];</span><br><span class="line">                    arr[j] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        bubbleSort(array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(array[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>冒泡排序性能较低， Java 中内置了更高效的排序算法</p><p><code>Arrays.sort</code> 是 Java 中 <code>java.util.Arrays</code> 类提供的一组实用方法，用于对数组进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[] arr = &#123;<span class="number">12</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">15</span>, <span class="number">1</span>, <span class="number">10</span>&#125;;</span><br><span class="line">       <span class="comment">// 对数组进行排序</span></span><br><span class="line">       Arrays.sort(arr);</span><br><span class="line">       <span class="comment">// 输出排序后的数组</span></span><br><span class="line">       System.out.println(<span class="string">&quot;排序后: &quot;</span> + Arrays.toString(arr));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="5、数组的拷贝">5、数组的拷贝</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] cope (<span class="type">int</span>[] array)&#123;</span><br><span class="line">    <span class="type">int</span> [] copearray = <span class="keyword">new</span> <span class="title class_">int</span>[array.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        copearray[i] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copearray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] ret = cope(array);</span><br><span class="line">    System.out.println(Arrays.toString(ret));</span><br><span class="line">    System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">    <span class="type">int</span>[] ret2 = Arrays.copyOf(array,array.length);</span><br><span class="line">    System.out.println(Arrays.toString(ret2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：数组当中存储的是基本类型数据时，不论怎么拷贝基本都不会出现什么问题，但如果存储的是引用数据类型，拷贝时需要考虑深浅拷贝的问题。</p>]]></content>
    
    
    <summary type="html">JavaSE：Java中数组的应用</summary>
    
    
    
    <category term="笔记" scheme="https://www.zxhy.club/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://www.zxhy.club/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据结构航行之旅：探索顺序表的世界</title>
    <link href="https://www.zxhy.club/posts/vector.html"/>
    <id>https://www.zxhy.club/posts/vector.html</id>
    <published>2023-05-24T14:20:00.000Z</published>
    <updated>2023-05-24T15:03:26.987Z</updated>
    
    <content type="html"><![CDATA[<h1>一、前言</h1><p>数据结构是我们处理和组织数据的基础。不同的数据结构适用于不同的应用场景，而顺序表作为其中最基础且重要的一种结构，扮演着不可或缺的角色。顺序表是一种线性表的实现方式，通过使用连续的存储空间存储相同类型的元素，提供了快速随机访问的能力。这种特性使得顺序表成为了处理大量数据、高效查找和索引的理想选择。此刻，我们将乘坐数据结构这艘大船，一起探索顺序表的世界。</p><h1>二、结构定义</h1><p>顺序表本质就是数组，顺序表是用一段<strong>连续的存储单元依次存储数据元素</strong>的线性结构。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305242057527.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 vector 结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">vector</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;   <span class="comment">// vector 可容纳元素的数量</span></span><br><span class="line">    <span class="type">int</span> count;  <span class="comment">// vector 中元素的个数</span></span><br><span class="line">    <span class="type">int</span>* data;  <span class="comment">// 存储 vector 元素的数组</span></span><br><span class="line">&#125; <span class="built_in">vector</span>;</span><br></pre></td></tr></table></figure><p><code>typedef</code> 关键字，可以为这个结构体类型取了一个新的名字 <code>vector</code>，使得我们可以在后续的代码中使用 <code>vector</code> 作为类型名来声明变量。</p><h1>三、结构操作</h1><h2 id="1、获取顺序表">1、获取顺序表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个新的顺序表，存储元素数量为 n</span></span><br><span class="line"><span class="built_in">vector</span>* <span class="title function_">getNewVector</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>* p = (<span class="built_in">vector</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">vector</span>));  <span class="comment">// 动态分配结构体内存</span></span><br><span class="line">    p-&gt;size = n;  <span class="comment">// 初始化 size</span></span><br><span class="line">    p-&gt;count = <span class="number">0</span>;  <span class="comment">// 初始化 count</span></span><br><span class="line">    p-&gt;data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);  <span class="comment">// 动态分配存储数组内存</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、销毁顺序表">2、销毁顺序表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放 vector 的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">(<span class="built_in">vector</span>* v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) <span class="keyword">return</span>;  <span class="comment">// 如果 v 为空，则直接返回</span></span><br><span class="line">    <span class="built_in">free</span>(v-&gt;data);  <span class="comment">// 释放存储数组内存</span></span><br><span class="line">    <span class="built_in">free</span>(v);    <span class="comment">// 释放结构体内存</span></span><br><span class="line">    v = <span class="literal">NULL</span>;<span class="comment">// 将顺序表指针置为空指针</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意：如果将 <code>free(v)</code>这段代码 放在 <code>free(v-&gt;data)</code> 之前，就会导致潜在的<strong>内存泄漏</strong>。</p><p>这是因为 <code>v-&gt;data</code> 是存储在顺序表结构体 <code>v</code> 中的指针，如果先释放了 <code>v</code>，那么在释放 <code>v-&gt;data</code> 之前就无法访问到 <code>v-&gt;data</code>，从而无法释放存储数组所占用的内存。</p><h2 id="3、扩容操作">3、扩容操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩容 vector，返回是否扩容成功</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">expand</span><span class="params">(<span class="built_in">vector</span>* v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 如果 v 为空，则返回 0 表示扩容失败</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;expand v from %d to %d\n&quot;</span>, v-&gt;size, <span class="number">2</span> * v-&gt;size);  <span class="comment">// 输出扩容信息</span></span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">realloc</span>(v-&gt;data, <span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span> * v-&gt;size);  <span class="comment">// 在原有内存大小的基础上扩容</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 如果扩容失败，则返回 0 表示扩容失败</span></span><br><span class="line">    v-&gt;data = p;  <span class="comment">// 将扩容后的内存地址赋值给 data</span></span><br><span class="line">    v-&gt;size *= <span class="number">2</span>;  <span class="comment">// 更新 size 的值，表示 vector 可容纳元素的数量为原来的 2 倍</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 扩容成功，返回 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了 <code>realloc</code> 函数重新分配内存空间。</p><p><code>realloc</code> 函数的第一个参数是原有内存块的指针，第二个参数是新的内存大小。在这里，代码使用 <code>sizeof(int) * 2 * v-&gt;size</code> 来计算新的内存大小，即原有内存大小的两倍。扩容操作使得顺序表能够容纳更多的元素，避免了因空间不足而导致的溢出问题。在扩容过程中，代码使用 <code>realloc</code> 函数来重新分配内存，并根据返回结果判断扩容是否成功。成功后，将新的内存地址赋值给顺序表的 <code>data</code> 成员，并更新容量大小。</p><h2 id="4、插入操作">4、插入操作</h2><p>首先，我们需要检查插入位置是否有效，即是否在合理的范围内。插入位置应该大于等于 0，小于等于当前元素个数 <code>count</code>。如果插入位置无效，则插入操作无法进行。其次，检查顺序表是否已满：如果顺序表的当前元素个数 <code>count</code> 达到了顺序表的最大容量 <code>size</code>，则表示顺序表已满，无法插入新的元素。在这种情况下，要进行扩容操作。然后，后移元素，从插入位置开始，将插入位置之后的所有元素向后移动一个位置，为新元素腾出插入的位置。可以使用循环遍历或者从最后一个元素开始逐个后移的方式。接下来，将要插入的新元素放入插入位置处，更新顺序表中的元素个数 <code>count</code>。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305242115228.gif" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在指定位置插入元素，返回是否插入成功</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(<span class="built_in">vector</span>* v, <span class="type">int</span> pos, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt; v-&gt;count) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 如果指定位置不合法，则返回 0 表示插入失败</span></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;size == v-&gt;count &amp;&amp; !expand(v)) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 如果 vector 已满且扩容失败，则返回 0 表示插入失败</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = v-&gt;count - <span class="number">1</span>; i &gt;= pos; i--) &#123;</span><br><span class="line">        v-&gt;data[i + <span class="number">1</span>] = v-&gt;data[i];  <span class="comment">// 将 pos 及之后的元素后移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    v-&gt;data[pos] = val;  <span class="comment">// 将 val 插入到指定位置</span></span><br><span class="line">    v-&gt;count += <span class="number">1</span>;  <span class="comment">// 更新 count 的值，表示 vector 中元素的个数加 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 插入成功，返回 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、删除操作">5、删除操作</h2><p>首先，需要检查删除位置是否有效，即是否在合理的范围内。删除位置应该大于等于 0，小于当前元素个数 <code>count</code>。如果删除位置无效，则删除操作无法进行。然后，从删除位置开始，将删除位置之后的所有元素向前移动一位，可以使用循环遍历或者从删除位置开始逐个前移的方式，覆盖掉要删除的元素。最好将顺序表中的元素个数 <code>count</code> 减 1，更新一下 <code>count</code>的值。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305242158550.gif" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定位置的元素，返回是否删除成功</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">erase</span><span class="params">(<span class="built_in">vector</span>* v, <span class="type">int</span> pos)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt;= v-&gt;count) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 如果指定位置不合法，则返回 0 表示删除失败</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos + <span class="number">1</span>; i &lt; v-&gt;count; i++) &#123;</span><br><span class="line">        v-&gt;data[i - <span class="number">1</span>] = v-&gt;data[i];  <span class="comment">// 将 pos 之后的元素前移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    v-&gt;count -= <span class="number">1</span>;  <span class="comment">// 更新 count 的值，表示 vector 中元素的个数减 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 删除成功，返回 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、输出操作">6、输出操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">output_vector</span><span class="params">(<span class="built_in">vector</span>* v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid vector.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 输出每个元素的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v-&gt;size; i++) &#123;</span><br><span class="line">        len += <span class="built_in">printf</span>(<span class="string">&quot;%6d&quot;</span>, i);  <span class="comment">// 调整格式化输出宽度为 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出分隔线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出每个元素的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v-&gt;count; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%6d&quot;</span>, v-&gt;data[i]);  <span class="comment">// 调整格式化输出宽度为 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、代码测试">7、代码测试</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 定义 vector 结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">vector</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;   <span class="comment">// vector 可容纳元素的数量</span></span><br><span class="line">    <span class="type">int</span> count;  <span class="comment">// vector 中元素的个数</span></span><br><span class="line">    <span class="type">int</span>* data;  <span class="comment">// 存储 vector 元素的数组</span></span><br><span class="line">&#125; <span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个新的 vector，存储元素数量为 n</span></span><br><span class="line"><span class="built_in">vector</span>* <span class="title function_">getNewVector</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>* p = (<span class="built_in">vector</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">vector</span>));  <span class="comment">// 动态分配结构体内存</span></span><br><span class="line">    p-&gt;size = n;  <span class="comment">// 初始化 size</span></span><br><span class="line">    p-&gt;count = <span class="number">0</span>;  <span class="comment">// 初始化 count</span></span><br><span class="line">    p-&gt;data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);  <span class="comment">// 动态分配存储数组内存</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容 vector，返回是否扩容成功</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">expand</span><span class="params">(<span class="built_in">vector</span>* v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 如果 v 为空，则返回 0 表示扩容失败</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;expand v from %d to %d\n&quot;</span>, v-&gt;size, <span class="number">2</span> * v-&gt;size);  <span class="comment">// 输出扩容信息</span></span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">realloc</span>(v-&gt;data, <span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span> * v-&gt;size);  <span class="comment">// 在原有内存大小的基础上扩容</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 如果扩容失败，则返回 0 表示扩容失败</span></span><br><span class="line">    v-&gt;data = p;  <span class="comment">// 将扩容后的内存地址赋值给 data</span></span><br><span class="line">    v-&gt;size *= <span class="number">2</span>;  <span class="comment">// 更新 size 的值，表示 vector 可容纳元素的数量为原来的 2 倍</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 扩容成功，返回 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置插入元素，返回是否插入成功</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(<span class="built_in">vector</span>* v, <span class="type">int</span> pos, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt; v-&gt;count) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 如果指定位置不合法，则返回 0 表示插入失败</span></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;size == v-&gt;count &amp;&amp; !expand(v)) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 如果 vector 已满且扩容失败，则返回 0 表示插入失败</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = v-&gt;count - <span class="number">1</span>; i &gt;= pos; i--) &#123;</span><br><span class="line">        v-&gt;data[i + <span class="number">1</span>] = v-&gt;data[i];  <span class="comment">// 将 pos 及之后的元素后移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    v-&gt;data[pos] = val;  <span class="comment">// 将 val 插入到指定位置</span></span><br><span class="line">    v-&gt;count += <span class="number">1</span>;  <span class="comment">// 更新 count 的值，表示 vector 中元素的个数加 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 插入成功，返回 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定位置的元素，返回是否删除成功</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">erase</span><span class="params">(<span class="built_in">vector</span>* v, <span class="type">int</span> pos)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt;= v-&gt;count) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 如果指定位置不合法，则返回 0 表示删除失败</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos + <span class="number">1</span>; i &lt; v-&gt;count; i++) &#123;</span><br><span class="line">        v-&gt;data[i - <span class="number">1</span>] = v-&gt;data[i];  <span class="comment">// 将 pos 之后的元素前移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    v-&gt;count -= <span class="number">1</span>;  <span class="comment">// 更新 count 的值，表示 vector 中元素的个数减 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 删除成功，返回 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 vector 中的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">output_vector</span><span class="params">(<span class="built_in">vector</span>* v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid vector.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v-&gt;size; i++) &#123;</span><br><span class="line">        len += <span class="built_in">printf</span>(<span class="string">&quot;%6d&quot;</span>, i);  <span class="comment">// 调整格式化输出宽度为 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v-&gt;count; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%6d&quot;</span>, v-&gt;data[i]);  <span class="comment">// 调整格式化输出宽度为 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放 vector 的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">(<span class="built_in">vector</span>* v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) <span class="keyword">return</span>;  <span class="comment">// 如果 v 为空，则直接返回</span></span><br><span class="line">    <span class="built_in">free</span>(v-&gt;data);  <span class="comment">// 释放存储数组内存</span></span><br><span class="line">    <span class="built_in">free</span>(v);  <span class="comment">// 释放结构体内存</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));  <span class="comment">// 生成随机数种子</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_OP 20  <span class="comment">// 定义执行操作的最大数量</span></span></span><br><span class="line">    <span class="built_in">vector</span>* v = getNewVector(<span class="number">2</span>);  <span class="comment">// 创建一个存储元素数量为 2 的 vector</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_OP; i++) &#123;</span><br><span class="line">        <span class="type">int</span> op = rand() % <span class="number">4</span>, pos, val, ret;</span><br><span class="line">        <span class="comment">// 随机生成要执行的操作（0-3），要插入的位置，要插入的值，是否插入/删除成功</span></span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            pos = rand() % (v-&gt;count + <span class="number">2</span>);  <span class="comment">// 随机生成要插入的位置</span></span><br><span class="line">            val = rand() % <span class="number">100</span>;  <span class="comment">// 随机生成要插入的值</span></span><br><span class="line">            ret = insert(v, pos, val);  <span class="comment">// 执行插入操作，并获取是否插入成功的信息</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;insert %d at %d to vector = %d\n&quot;</span>,</span><br><span class="line">                val, pos, ret);  <span class="comment">// 输出插入的值、插入的位置以及是否插入成功的信息</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            pos = rand() % (v-&gt;count + <span class="number">2</span>);  <span class="comment">// 随机生成要删除的位置</span></span><br><span class="line">            ret = erase(v, pos);  <span class="comment">// 执行删除操作，并获取是否删除成功的信息</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;erase item at %d in vector = %d\n&quot;</span>,</span><br><span class="line">                pos, ret);  <span class="comment">// 输出要删除的位置以及是否删除成功的信息</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output_vector(v);  <span class="comment">// 输出 vector 中的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    clear(v);  <span class="comment">// 释放 vector 的内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305242213353.png" alt=""></p><h1>四、顺序表容器</h1><h2 id="1、vector（C-）">1、<code>vector</code>（C++）</h2><p>在C++中，顺序表的库称为标准模板库（<code>STL</code>），其中的顺序表容器称为 <code>vector</code>。当使用 C++ 中的 <code>vector</code> 容器时，需要包含 <code>&lt;vector&gt;</code> 头文件。</p><h3 id="Ⅰ、常用功能">Ⅰ、常用功能</h3><p>可以利用以下常用的功能来操作和管理动态数组的顺序表：</p><p>1、添加和访问元素：</p><ul><li><code>push_back(value)</code>: 在 vector 的末尾添加一个元素。</li><li><code>pop_back()</code>: 删除 vector 的末尾元素。</li><li><code>insert(pos, value)</code>: 在指定位置插入一个元素。</li><li><code>erase(pos)</code>: 删除指定位置的元素。</li><li><code>at(index)</code>: 访问指定索引位置的元素。</li><li><code>front()</code>: 访问 vector 的第一个元素。</li><li><code>back()</code>: 访问 vector 的最后一个元素。</li></ul><p>2、大小和容量管理：</p><ul><li><code>size()</code>: 获取 vector 中元素的个数。</li><li><code>empty()</code>: 检查 vector 是否为空。</li><li><code>capacity()</code>: 获取 vector 当前分配的内存容量。</li><li><code>reserve(n)</code>: 预分配至少能容纳 n 个元素的内存空间。</li><li><code>resize(n)</code>: 调整 vector 的大小为 n。</li></ul><p>3、迭代访问和遍历：</p><ul><li>使用迭代器遍历 vector 中的元素。例如，使用 <code>begin()</code> 和 <code>end()</code> 成员函数获取迭代器的起始和结束位置，然后使用循环或算法进行遍历。</li><li>可以使用 range-based for 循环来遍历 vector 中的元素。</li></ul><p>4、清空和重置容器：</p><ul><li><code>clear()</code>: 清空 vector 中的所有元素。</li><li><code>assign(n, value)</code>: 将 vector 中的元素重置为 n 个 value。</li></ul><p>5、其他功能：</p><ul><li><code>swap(other)</code>: 交换两个 vector 容器的内容。</li><li><code>erase(remove(value))</code>: 删除 vector 中所有等于给定值的元素。</li><li><code>sort()</code>: 对 vector 中的元素进行排序。</li><li><code>find(value)</code>: 在 vector 中查找给定值的元素，并返回。</li></ul><h3 id="Ⅱ、举个例子">Ⅱ、举个例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; numbers;  <span class="comment">// 创建一个整数类型的 vector</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素到 vector</span></span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 vector 的大小和元素个数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of vector: %zu\n&quot;</span>, numbers.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number of elements in vector: %zu\n&quot;</span>, numbers.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问和修改元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First element: %d\n&quot;</span>, numbers[<span class="number">0</span>]);</span><br><span class="line">    numbers[<span class="number">1</span>] = <span class="number">25</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Modified second element: %d\n&quot;</span>, numbers[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用下标遍历元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Elements in vector: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 vector 是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (numbers.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Vector is empty.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Vector is not empty.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空 vector</span></span><br><span class="line">    numbers.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of vector after clear: %zu\n&quot;</span>, numbers.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、ArrayList（Java）">2、<code>ArrayList</code>（Java）</h2><p>在Java中，顺序表的库称为集合框架（Collection Framework），其中的顺序表容器称为 <code>ArrayList</code>。</p><p>当使用Java中的<code>ArrayList</code>容器时，需要导入<code>java.util</code>包。</p><h3 id="Ⅰ、常用功能-2">Ⅰ、常用功能</h3><p>可以利用以下常用的功能来操作和管理动态数组的顺序表：</p><p>1、添加和访问元素：</p><ul><li><code>add(element)</code>: 在ArrayList的末尾添加一个元素。</li><li><code>remove(index)</code>: 删除指定索引位置的元素。</li><li><code>get(index)</code>: 访问指定索引位置的元素。</li><li><code>set(index, element)</code>: 修改指定索引位置的元素。</li><li><code>size()</code>: 获取ArrayList中元素的个数。</li></ul><p>2、迭代访问和遍历：</p><ul><li>使用迭代器遍历ArrayList中的元素。可以使用<code>Iterator</code>或<code>ListIterator</code>进行迭代，遍历元素并进行相应操作。</li></ul><p>3、清空和重置容器：</p><ul><li><code>clear()</code>: 清空ArrayList中的所有元素。</li></ul><p>4、其他功能：</p><ul><li><code>contains(element)</code>: 检查ArrayList是否包含指定元素。</li><li><code>indexOf(element)</code>: 获取指定元素第一次出现的索引位置。</li><li><code>lastIndexOf(element)</code>: 获取指定元素最后一次出现的索引位置。</li><li><code>isEmpty()</code>: 检查ArrayList是否为空。</li></ul><h3 id="Ⅱ、举个例子-2">Ⅱ、举个例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">// 创建一个整数类型的ArrayList</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到ArrayList</span></span><br><span class="line">        numbers.add(<span class="number">10</span>);</span><br><span class="line">        numbers.add(<span class="number">20</span>);</span><br><span class="line">        numbers.add(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ArrayList的大小和元素个数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ArrayList的大小：&quot;</span> + numbers.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;ArrayList中的元素个数：&quot;</span> + numbers.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问和修改元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一个元素：&quot;</span> + numbers.get(<span class="number">0</span>));</span><br><span class="line">        numbers.set(<span class="number">1</span>, <span class="number">25</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改后的第二个元素：&quot;</span> + numbers.get(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用for循环遍历元素</span></span><br><span class="line">        System.out.print(<span class="string">&quot;ArrayList中的元素：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numbers.size(); i++) &#123;</span><br><span class="line">            System.out.print(numbers.get(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查ArrayList是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (numbers.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ArrayList为空。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ArrayList不为空。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空ArrayList</span></span><br><span class="line">        numbers.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;清空ArrayList后的大小：&quot;</span> + numbers.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构：顺序表，数据结构的开始</summary>
    
    
    
    <category term="笔记" scheme="https://www.zxhy.club/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据结构" scheme="https://www.zxhy.club/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java学习之旅：类和对象</title>
    <link href="https://www.zxhy.club/posts/java07.html"/>
    <id>https://www.zxhy.club/posts/java07.html</id>
    <published>2023-05-09T09:28:23.000Z</published>
    <updated>2023-05-09T15:08:36.694Z</updated>
    
    <content type="html"><![CDATA[<h1>一、前言</h1><p>Java是一种广泛应用于各个领域的编程语言，它的面向对象编程范式使得它成为了当今软件开发的主要选择之一。通过面向对象编程，Java使程序员能够将代码组织成易于理解和维护的结构，并且在开发大型复杂的应用程序时提供了许多便利。</p><p>与传统的过程式编程不同，面向对象编程将程序组织成一系列相互独立的对象，每个对象都有自己的属性和行为，它们可以通过消息传递来与其他对象交互。这种编程范式使得代码更易于重用、扩展和测试，并且有助于提高代码的可维护性和可读性。</p><p>在本博客中，我们将一起探讨Java面向对象编程的基础概念。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305071739379.png" alt=""></p><h2 id="1、什么是面向过程">1、什么是面向过程</h2><p>C语言就算一门面向过程的语言，面向过程编程（Procedural Programming）是一种计算机编程方法，其核心思想是将程序视为一系列的过程或函数，每个过程或函数都是完成一个特定的任务。面向过程编程强调步骤与逻辑的过程管理，需要手动编写代码实现每一步骤。在面向过程编程中，数据和方法是分离的，通常使用全局变量进行数据传递。因此，面向过程编程通常被认为是较低级别的编程方式，其主要用途是解决简单或特定的问题。</p><h2 id="2、什么是面向对象">2、什么是面向对象</h2><p>Java是一门纯面向对象的语言(Object Oriented Program，简称OOP)，在面向对象的世界里，一切皆为对象。<strong>面向对象是解决问题的一种思想，主要依靠对象之间的交互完成一件事情</strong>。用面向对象的思想来涉及程序，更符合人们对事物的认知，对于大型程序的设计、扩展以及维护都非常友好。</p><h2 id="3、两者的区别">3、两者的区别</h2><p><strong>以洗衣服为例：</strong></p><p>面向过程编程就像手洗衣服一样。你需要了解每个步骤，例如：湿润衣服、涂上洗涤剂、用刷子刷洗、用水冲洗、拧干等等。你需要自己决定每个步骤，并进行大量的手动操作。而面向对象编程就像使用洗衣机一样。你只需要将脏衣服放进洗衣机，按下按钮，然后洗衣机会自动完成一系列步骤，包括添加水、调节温度、旋转等操作。你不必关心每个步骤，只需要掌握使用洗衣机的方法，就能完成整个洗衣服的过程。</p><p>**在面向过程编程中，我们需要手动实现每个步骤，而在面向对象编程中，我们只需要使用已经编写好的对象来完成任务。**这就是两者的区别。</p><p>在面向对象编程中，对象是一个封装了方法和属性的实体，我们可以通过使用这些对象来完成一系列的操作，无需手动实现每个步骤，这也减轻了开发工作的繁琐程度。</p><p><strong>但是要注意：面向过程和面相对象并不是一门语言，而是解决问题的方法，没有那个好坏之分，都有其专门的应用场景。</strong></p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305051423356.png" alt="image-20230505142300214"></p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305051424176.png" alt="image-20230505142400095"></p><h1>三、类</h1><h2 id="1、类的定义">1、类的定义</h2><p>在面向对象编程中，类（Class）是一种定义对象的蓝图或模板。类描述了一个对象具有的属性和方法，它是创建对象的基础，所有具有相同属性和方法的对象都属于同一个类。类通常包含数据成员（属性）和函数成员（方法）。属性是类中的变量，描述了对象的基本信息，而方法是类中的函数，用于实现对象的各种行为。</p><p>举个简单例子，假设我们要创建一个汽车类，那么我们可以定义该类的属性包括汽车的品牌、型号、颜色等等，方法包括发动、刹车、加速等等。当我们使用该类创建一个具体的对象时，这个对象就会具有该类描述的所有属性和方法。</p><p>在<strong>Java中定义类时需要用到<code>class</code>关键字</strong>，具体语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;</span><br><span class="line">    field; <span class="comment">// 字段(属性) 或者 成员变量（定义在类中，但是在方法的外面）</span></span><br><span class="line">    method; <span class="comment">// 行为 或者 成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>class</code>是Java语言中用于定义类的关键字；</li><li><code>ClassName</code>是要定义的类的名称，命名规则和Java语言的标识符命名规则相同，采用大驼峰命名法；</li><li>{}中是类的主体，包含了类的所有属性和方法。</li><li>类中包含的内容称为类的成员。属性主要是用来描述类的，称之为类的成员属性或者类成员变量。方法主要说明类具有哪些功能，称为类的成员方法。</li></ul><h2 id="2、举点例子">2、举点例子</h2><h3 id="Ⅰ、定义一个汽车类">Ⅰ、定义一个汽车类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="comment">//定义汽车属性</span></span><br><span class="line">    <span class="keyword">private</span> String brand;   <span class="comment">//品牌</span></span><br><span class="line">    <span class="keyword">private</span> String model;   <span class="comment">//型号</span></span><br><span class="line">    <span class="keyword">private</span> String color;   <span class="comment">//颜色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> speed;   <span class="comment">//车速</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> fuel;    <span class="comment">//燃油量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义汽车方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汽车启动！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">brake</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汽车刹车！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accelerate</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汽车加速！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decelerate</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汽车减速！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ⅱ、定义一个学生类">Ⅱ、定义一个学生类</h3><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305052052733.png" alt="image-20230505205243649"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> String gender;</span><br><span class="line"><span class="keyword">public</span> <span class="type">short</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> score;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DoClass</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DoHomework</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Exam</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li><p>一般一个文件当中只定义一个类</p></li><li><p>main方法所在的类一般要使用<code>public</code>修饰(注意：Eclipse默认会在<code>public</code>修饰的类中找main方法)</p></li><li><p><code>public</code>修饰的类必须要和文件名相同</p></li></ul><h2 id="3、类的实例化">3、类的实例化</h2><p>类的实例化是指根据一个类创建一个具体的对象，这个对象就是该类的一个实例。在面向对象编程中，类是一种抽象的概念，而对象则是具体的实体。通过类的实例化，我们可以创建多个不同的对象，每个对象都有自己独立的属性和方法。</p><p>在Java中，我们通过使用<code>new</code>关键字来创建一个类的实例，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Car</span> <span class="variable">myCar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br></pre></td></tr></table></figure><p>上面的代码就创建了一个<code>Car</code>类的实例，并将其赋给一个变量<code>myCar</code>。通过该变量，我们可以访问这个具体的<code>Car</code>对象的属性和方法，这个<code>myCar</code>变量是一个引用变量，它包含了指向实际<code>Car</code>对象的内存地址。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305072141792.png" alt="image-20230507214153700"></p><blockquote><p>在Java中，对象是存储在堆内存中的，而变量是存储在栈内存中的。当使用<code>new</code>关键字创建一个对象时，Java会在堆内存中分配一块新的内存空间，并返回该对象的引用。这个引用可以被存储在一个变量中，以便在程序中引用该对象。</p><p>上面的这段Java代码，其实就是创建了一个名为<code>myCar</code>的引用变量，并使用<code>new</code>关键字在堆内存中创建了一个新的<code>Car</code>对象，然后将该对象的引用赋值给了<code>myCar</code>变量。</p></blockquote><p><strong>注意事项</strong></p><ul><li><p><code>new</code> 关键字用于创建一个对象的实例</p></li><li><p>使用 <code>. </code>来访问对象中的属性和方法</p></li><li><p>同一个类可以创建对个实例</p></li></ul><h2 id="4、类和对象的说明">4、类和对象的说明</h2><p><strong>类只是</strong>一个<strong>模型</strong>一样的东西，用来对一个实体进行描述，限定了类有哪些成员。</p><p><strong>类是一种自定义的类型</strong>，可以用来定义变量。一个类可以实例化出多个对象，<strong>实例化出的对象 占用实际的物理空间，存储类成员变量</strong>。</p><p><strong>类定义了对象的结构和行为，而对象是类的一个具体实例，具有自己独立的属性和方法。</strong></p><p>做个比方。<strong>类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图</strong>，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占用物理空间。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305052128616.png" alt="image-20230505212813507"></p><h1>四、this引用</h1><h2 id="1、为什么要有this引用">1、为什么要有this引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> year;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> month;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> day;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDay</span><span class="params">(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d)</span>&#123;</span><br><span class="line">year = y;</span><br><span class="line">month = m;</span><br><span class="line">day = d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printDate</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(year + <span class="string">&quot;/&quot;</span> + month + <span class="string">&quot;/&quot;</span> + day);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 构造三个日期类型的对象 d1 d2 d3</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">Date</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">// 对d1，d2，d3的日期设置</span></span><br><span class="line">    d1.setDay(<span class="number">2020</span>,<span class="number">9</span>,<span class="number">15</span>);</span><br><span class="line">    d2.setDay(<span class="number">2020</span>,<span class="number">9</span>,<span class="number">16</span>);</span><br><span class="line">    d3.setDay(<span class="number">2020</span>,<span class="number">9</span>,<span class="number">17</span>);</span><br><span class="line">    <span class="comment">// 打印日期中的内容</span></span><br><span class="line">    d1.printDate();</span><br><span class="line">    d2.printDate();</span><br><span class="line">    d3.printDate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305072311417.png" alt="image-20230507231123329"></p><p>以上代码定义了一个日期类，然后main方法中创建了三个对象，并通过Date类中的成员方法对对象进行设置和打印，代码整体逻辑非常简单，没有任何问题。</p><p>但是细思之下有以下两个疑问：</p><p><strong>1、形参名不小心与成员变量名相同</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDay</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span>&#123;</span><br><span class="line">year = year;</span><br><span class="line">month = month;</span><br><span class="line">day = day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那函数体中到底是谁给谁赋值？成员变量给成员变量？参数给参数？参数给成员变量？成员变量参数？。</p><p><strong>2、<strong>三个对象都在调用<code>setDate</code>和<code>printDate</code>函数，但是这两个函数中没有任何有关对象的说明，</strong><code>setDate</code>和<code>printDate</code>函数如何知道打印的是那个对象的数据呢</strong>？</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305052137548.png" alt="image-20230505213724485"></p><h2 id="2、什么是this引用">2、什么是this引用</h2><p>this引用指向当前对象(成员方法运行时调用该成员方法的对象)，在成员方法中所有成员变量的操作，都是通过该引用去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。</p><p>this引用的作用就是区分成员变量和局部变量：当一个方法的参数名和对象的成员变量名相同时，使用<code>this</code>关键字可以指明是使用对象的成员变量，还是方法的局部变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> year;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> month;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> day;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDay</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.year = year;</span><br><span class="line">    <span class="built_in">this</span>.month = month;</span><br><span class="line">    <span class="built_in">this</span>.day = day;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printDate</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="built_in">this</span>.year + <span class="string">&quot;/&quot;</span> + <span class="built_in">this</span>.month + <span class="string">&quot;/&quot;</span> + <span class="built_in">this</span>.day);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意：<strong>this引用的是调用成员方法的对象</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    d.setDay(<span class="number">2020</span>,<span class="number">9</span>,<span class="number">15</span>);</span><br><span class="line">    d.printDate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305052139012.png" alt="image-20230505213912951"></p><h2 id="3、-this引用的特性">3、 this引用的特性</h2><p>1、 this的类型：对应类类型引用，即哪个对象调用就是哪个对象的引用类型</p><p>2、<strong>this只能在&quot;成员方法&quot;中使用</strong></p><p>3、在&quot;成员方法&quot;中，this只能引用当前对象，不能再引用其他对象</p><p>4、this是“成员方法”第一个隐藏的参数，编译器会自动传递，在成员方法执行时，编译器会负责将调用成员方法对象的引用传递给该成员方法，this负责来接收。</p><p><strong>在代码层面来简单演示—&gt;注意：下图右侧中的Date类也是可以通过编译的：</strong></p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305052140473.png" alt="image-20230505214024408"></p><h1>五、对象构造及初始化</h1><h2 id="1、如何初始化对象">1、如何初始化对象</h2><p>通过前面知识点的学习知道，在Java方法内部定义一个局部变量时，必须要初始化，否则会编译失败。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码，编译的时候就会出现：<code>Error:(26, 28) java: 可能尚未初始化变量a</code>的报错提醒！</p><p>要让上述代码通过编译，非常简单，只需在正式使用a之前，给a设置一个初始值即可。</p><p>如果是对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    d.printDate();</span><br><span class="line">    d.setDate(<span class="number">2021</span>,<span class="number">6</span>,<span class="number">9</span>);</span><br><span class="line">    d.printDate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要调用之前写的<code>SetDate</code>方法才可以将具体的日期设置到对象中。<strong>通过上述例子发现两个问题：</strong></p><p>1、<strong>每次对象创建好后调用<code>SetDate</code>方法设置具体日期，比较麻烦，那对象该如何初始化？</strong></p><blockquote><p>为了避免这种问题，我们可以在对象的构造方法中设置初始值，这样对象一旦创建，就会立即拥有完整的状态。在 Java 中，我们可以使用构造方法来完成对象的初始化工作。</p></blockquote><p>2、<strong>局部变量必须要初始化才能使用，为什么字段声明之后没有给值依然可以使用？</strong></p><blockquote><p>在Java中，局部变量必须在使用之前先进行初始化，否则编译器会报错。这是因为局部变量的生命周期只在其所在的方法内部，而且局部变量的值是不可靠的，如果没有初始化就使用它，可能会导致程序出现异常。</p><p>而类成员变量（字段）则不同，它们在类的实例化过程中被分配内存空间并赋予默认值，因此即使没有给字段初始化也可以使用。具体来说，Java会为不同类型的字段设置默认值：</p><ul><li>对于数值类型（byte、short、int、long、float、double），默认值为0或0.0。</li><li>对于布尔类型（boolean），默认值为false。</li><li>对于字符类型（char），默认值为null字符。</li><li>对于引用类型（类、接口、数组等），默认值为null。</li></ul><p>当然，如果我们需要的话，我们也可以在字段声明的时候给它们赋初值。这样做可以保证程序的健壮性，避免不必要的错误。</p></blockquote><h2 id="2、什么是构造方法">2、什么是构造方法</h2><p>构造方法是一种特殊的方法，用于在创建对象时初始化对象的状态。构造方法的名字必须与类名相同，它没有返回值，也不能手动调用。在创建对象时，Java 编译器会自动调用与对象类型相应的构造方法，并执行其中的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> year; <span class="comment">// 成员变量：年</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> month; <span class="comment">// 成员变量：月</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> day; <span class="comment">// 成员变量：日</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法：</span></span><br><span class="line">    <span class="comment">// 名字与类名相同，没有返回值类型，设置为void也不行</span></span><br><span class="line">    <span class="comment">// 一般情况下使用public修饰</span></span><br><span class="line">    <span class="comment">// 在创建对象时由编译器自动调用，并且在对象的生命周期内只调用一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Date</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.year = year; <span class="comment">// 使用this关键字访问对象的成员变量，并为其赋初值</span></span><br><span class="line">        <span class="built_in">this</span>.month = month;</span><br><span class="line">        <span class="built_in">this</span>.day = day;</span><br><span class="line">        System.out.println(<span class="string">&quot;Date(int,int,int)方法被调用了&quot;</span>); <span class="comment">// 构造方法执行完毕，输出消息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通方法：打印当前日期的字符串表示</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printDate</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(year + <span class="string">&quot;-&quot;</span> + month + <span class="string">&quot;-&quot;</span> + day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 此处创建了一个Date类型的对象，并没有显式调用构造方法</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2021</span>,<span class="number">6</span>,<span class="number">9</span>); <span class="comment">// 调用构造方法，传入三个整数参数</span></span><br><span class="line">        <span class="comment">// 上述代码相当于调用了以下语句：</span></span><br><span class="line">        <span class="comment">// Date d = new Date(); // 创建一个空对象</span></span><br><span class="line">        <span class="comment">// d.year = 2021; // 给成员变量赋值</span></span><br><span class="line">        <span class="comment">// d.month = 6;</span></span><br><span class="line">        <span class="comment">// d.day = 9;</span></span><br><span class="line">        <span class="comment">// 但是，使用构造方法的方式更加简洁和安全，可以保证对象的状态正确初始化</span></span><br><span class="line">        d.printDate(); <span class="comment">// 调用对象的方法，输出对象的状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么我没有写构造函数进行初始化，我的代码也没有报错呢？</p><blockquote><p>在Java中，如果你的构造方法一个都没写，编译器则会为你自动生成一个默认的无参构造方法。这个默认构造方法会接受所有类型的参数，并将它们设置为默认值(例如，int类型的参数会被设置为0,布尔类型的参数会被设置为false等)。</p></blockquote><h2 id="3、构造方法的特性">3、构造方法的特性</h2><ul><li>名字必须与类名相同</li><li>没有返回值类型，设置为void也不行</li><li>创建对象时由编译器自动调用，并且在对象的生命周期内只调用一次(相当于人的出生，每个人只能出生一次)</li><li>构造方法可以重载(用户根据自己的需求提供不同参数的构造方法)</li></ul><blockquote><p>在Java中，重载是指在同一个类中，有多个方法具有相同的名称但参数列表不同的情况。每个构造方法必须具有唯一的参数列表，因此当我们需要创建多个具有不同参数的构造方法时，就需要进行重载。重载的构造方法可以使用不同的参数数量、类型和顺序，从而在实例化对象时，根据传递的参数来调用不同的构造方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> year; <span class="comment">// 年份</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> month; <span class="comment">// 月份</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> day; <span class="comment">// 日期</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法，将日期初始化为1900年1月1日</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Date</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.year = <span class="number">1900</span>;</span><br><span class="line">        <span class="built_in">this</span>.month = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">this</span>.day = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带有三个参数的构造方法，根据参数设置日期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Date</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.year = year;</span><br><span class="line">        <span class="built_in">this</span>.month = month;</span><br><span class="line">        <span class="built_in">this</span>.day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日期的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printDate</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(year + <span class="string">&quot;-&quot;</span> + month + <span class="string">&quot;-&quot;</span> + day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// 创建一个日期对象，使用无参构造方法</span></span><br><span class="line">        d.printDate(); <span class="comment">// 调用打印日期的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上述两个构造方法：名字相同，参数列表不同，因此构成了方法重载。</strong></p><p>在构造方法中，可以通过<code>this</code>调用其他构造方法来简化代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> year;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> month;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> day;</span><br><span class="line">    <span class="comment">// 无参构造方法--内部给各个成员赋值初始值，该部分功能与三个参数的构造方法重复</span></span><br><span class="line">    <span class="comment">// 此处可以在无参构造方法中通过this调用带有三个参数的构造方法</span></span><br><span class="line">    <span class="comment">// 但是this(1900,1,1);必须是构造方法中第一条语句</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Date</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(year); 注释取消掉，编译会失败</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="number">1900</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//this.year = 1900;</span></span><br><span class="line">        <span class="comment">//this.month = 1;</span></span><br><span class="line">        <span class="comment">//this.day = 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 带有三个参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Date</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.year = year;</span><br><span class="line">        <span class="built_in">this</span>.month = month;</span><br><span class="line">        <span class="built_in">this</span>.day = day;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li><p>**this(…)**必须是构造方法中第一条语句</p></li><li><p><strong>不能形成闭环</strong></p></li><li><p>绝大多数情况下使用<code>public</code>来修饰，特殊场景下会被<code>private</code>修饰(单例模式时会遇到)</p></li><li><pre><code class="language-java">public Date()&#123;this(1900,1,1);&#125;public Date(int year, int month, int day) &#123;this();&#125;/*无参构造器调用三个参数的构造器，而三个参数构造器有调用无参的构造器，形成构造器的递归调用编译报错：Error:(19, 12) java: 递归构造器调用*/<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**每一个构造方法都需要我们自己写嘛？**</span><br><span class="line"></span><br><span class="line">我们可以自己写，也可以用idea生成构造方法。</span><br><span class="line"></span><br><span class="line">![<span class="built_in">image</span><span class="number">-20230508153727909</span>](https:<span class="comment">//zydx-520.oss-cn-beijing.aliyuncs.com/img/202305081537000.png)</span></span><br><span class="line"></span><br><span class="line">![<span class="built_in">image</span><span class="number">-20230508153742925</span>](https:<span class="comment">//zydx-520.oss-cn-beijing.aliyuncs.com/img/202305081537971.png)</span></span><br><span class="line"></span><br><span class="line">![<span class="built_in">image</span><span class="number">-20230508153839239</span>](https:<span class="comment">//zydx-520.oss-cn-beijing.aliyuncs.com/img/202305081538304.png)</span></span><br><span class="line"></span><br><span class="line">**这样我们就能生成一个构造函数了！**</span><br><span class="line"></span><br><span class="line">## <span class="number">4</span>、默认初始化</span><br><span class="line"></span><br><span class="line">**局部变量必须要初始化才能使用，为什么字段声明之后没有给值依然可以使用？**</span><br><span class="line"></span><br><span class="line">在Java中，局部变量必须在使用之前先进行初始化，否则编译器会报错。这是因为局部变量的生命周期只在其所在的方法内部，而且局部变量的值是不可靠的，如果没有初始化就使用它，可能会导致程序出现异常。</span><br><span class="line"></span><br><span class="line">而类成员变量（字段）则不同，它们在类的实例化过程中被分配内存空间并赋予默认值，因此即使没有给字段初始化也可以使用。具体来说，Java会为不同类型的字段设置默认值：</span><br><span class="line"></span><br><span class="line">- 对于数值类型（<span class="type">byte</span>、<span class="type">short</span>、<span class="type">int</span>、<span class="type">long</span>、<span class="type">float</span>、<span class="type">double</span>），默认值为<span class="number">0</span>或<span class="number">0.0</span>。</span><br><span class="line">- 对于布尔类型（<span class="type">boolean</span>），默认值为<span class="literal">false</span>。</span><br><span class="line">- 对于字符类型（<span class="type">char</span>），默认值为<span class="literal">null</span>字符（<span class="string">&#x27;\u0000&#x27;</span>）。</span><br><span class="line">- 对于引用类型（类、接口、数组等），默认值为<span class="literal">null</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当然，要想搞彻底清楚这个过程，就需要知道 <span class="keyword">new</span> 关键字背后所发生的一些事情：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="built_in">year</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="built_in">month</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="built_in">day</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Date</span>(<span class="type">int</span> <span class="built_in">year</span>, <span class="type">int</span> <span class="built_in">month</span>, <span class="type">int</span> <span class="built_in">day</span>) &#123;</span><br><span class="line">   <span class="comment">// 成员变量在定义时，并没有给初始值, 为什么就可以使用呢？</span></span><br><span class="line">       System.<span class="property">out</span>.<span class="property">println</span>(<span class="variable">this</span>.<span class="property">year</span>);</span><br><span class="line">       System.<span class="property">out</span>.<span class="property">println</span>(<span class="variable">this</span>.<span class="property">month</span>);</span><br><span class="line">       System.<span class="property">out</span>.<span class="property">println</span>(<span class="variable">this</span>.<span class="property">day</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">       <span class="comment">// 此处a没有初始化，编译时报错：</span></span><br><span class="line">       <span class="comment">// Error:(24, 28) java: 可能尚未初始化变量a</span></span><br><span class="line">       <span class="comment">// int a;</span></span><br><span class="line">       <span class="comment">// System.out.println(a);</span></span><br><span class="line">       Date d = <span class="keyword">new </span><span class="class title_">Date</span>(<span class="number">2021</span>,<span class="number">6</span>,<span class="number">9</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></blockquote><p>在程序层面只是简单的一条语句，在JVM层面需要做好多事情，下面简单介绍下：</p><ul><li><p>检测对象对应的类是否加载了，如果没有加载则加载</p></li><li><p>为对象分配内存空间</p></li><li><p>处理并发安全问题</p></li><li><p><strong>初始化所分配的空间</strong>：对象空间被申请好之后，对象中包含的成员已经设置好了初始值</p></li><li><p>设置对象头信息</p></li><li><p>调用构造方法，给对象中各个成员赋值</p></li></ul><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305061812857.png" alt="image-20230506181245732"></p><h2 id="5、就地初始化">5、就地初始化</h2><p>在声明成员变量时，就直接给出了初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> <span class="number">1900</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Date</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Date</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2021</span>,<span class="number">6</span>,<span class="number">9</span>);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：代码编译完成后，编译器会将所有给成员初始化的这些语句添加到各个构造函数中</p><h1>六、封装</h1><h2 id="1、封装的概念">1、封装的概念</h2><p><strong>面向对象程序三大特性：封装、继承、多态</strong>。而类和对象阶段，主要研究的就是封装特性。何为封装呢？简单来说就是<strong>套壳屏蔽细节</strong>。</p><p>比如：对于电脑这样一个复杂的设备，提供给用户的就只是：开关机、通过键盘输入，显示器，USB 插孔等，让用户来和计算机进行交互，完成日常事务。但实际上：电脑真正工作的却是CPU、显卡、内存等一些硬件元件。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305061852859.png" alt="image-20230506185257742"></p><p>对于计算机使用者而言，不用关心内部核心部件，比如主板上线路是如何布局的，CPU内部是如何设计的等，用户只需要知道，怎么开机、怎么通过键盘和鼠标与计算机进行交互即可。因此<strong>计算机厂商在出厂时，在外部套上壳子，将内部实现细节隐藏起来，仅仅对外提供开关机、鼠标以及键盘插孔等，让用户可以与计算机进行交互即可</strong>。</p><p><strong>封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。</strong></p><blockquote><p>在Java中，从语法层次上来看，使用关键字<code>private</code>就可以做到。</p><p>被<code>private</code>修饰的属性，只能在当前类中使用。</p></blockquote><h2 id="2、访问限定符">2、访问限定符</h2><p>在Java中，封装是通过访问控制符（<code>public</code>、<code>private</code>、<code>protected</code>）来实现的。通常情况下，类的属性都应该使用<code>private</code>修饰符来限制外部访问，而方法则可以使用<code>public</code>修饰符来允许外部访问，从而实现对内部状态的保护和控制。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305061921040.png" alt="image-20230506192122890"></p><p><code>public</code>：可以理解为一个人的外貌特征，谁都可以看得到</p><p><code>default</code>: 对于自己家族中(同一个包中)不是什么秘密，对于其他人来说就是隐私了</p><p><code>private</code>: 只有自己知道，其他人都不知道</p><p>【<strong>说明</strong>】</p><ul><li><p><code>protected</code>主要是在继承中使用</p></li><li><p><code>default</code>权限指：什么都不写时的默认权限</p></li><li><p>访问权限除了可以限定类中成员的可见性，也可以控制类的可见性</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu; <span class="comment">// cpu</span></span><br><span class="line">    <span class="keyword">private</span> String memory; <span class="comment">// 内存</span></span><br><span class="line">    <span class="keyword">public</span> String screen; <span class="comment">// 屏幕</span></span><br><span class="line">    String brand; <span class="comment">// 品牌----&gt;default属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">(String brand, String cpu, String memory, String screen)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">    <span class="built_in">this</span>.memory = memory;</span><br><span class="line">    <span class="built_in">this</span>.screen = screen;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Boot</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开机~~~&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PowerOff</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;关机~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SurfInternet</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;上网~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestComputer</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(<span class="string">&quot;HW&quot;</span>, <span class="string">&quot;i7&quot;</span>, <span class="string">&quot;8G&quot;</span>, <span class="string">&quot;13*14&quot;</span>);</span><br><span class="line">        System.out.println(p.brand); <span class="comment">// default属性：只能被本包中类访问</span></span><br><span class="line">        System.out.println(p.screen); <span class="comment">// public属性： 可以任何其他类访问</span></span><br><span class="line">        <span class="comment">// System.out.println(p.cpu); // private属性：只能在Computer类中访问，不能被其他类访问</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：一般情况下成员变量设置为<code>private</code>，成员方法设置为<code>public</code>。</p><h2 id="3、封装拓展：包">3、封装拓展：包</h2><h3 id="Ⅰ、包的概念">Ⅰ、包的概念</h3><p>在面向对象体系中，提出了一个软件包的概念，即：<strong>为了更好的管理类，把多个类收集在一起成为一组，称为软件包</strong>。有点类似于目录。比如：为了更好的管理电脑中的歌曲，一种好的方式就是将相同属性的歌曲放在相同文件下，也可以对某个文件夹下的音乐进行更详细的分类。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305061930217.png" alt="image-20230506193027137"></p><p>在Java中也引入了包，<strong>包是对类、接口等的封装机制的体现，是一种对类或者接口等的很好的组织方式</strong>。</p><p>比如：一个包中的类不想被其他包中的类使用。</p><p>包还有一个重要的作用：<strong>在同一个工程中允许存在相同名称的类，只要处在不同的包中即可</strong>。</p><h3 id="Ⅱ、导入包中的类">Ⅱ、导入包中的类</h3><p>Java 中已经提供了很多现成的类供我们使用.</p><p>例如Date类：可以使用 <code>java.util.Date</code> 导入 <code>java.util</code> 这个包中的 Date类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    java.util.<span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Date();</span><br><span class="line">    <span class="comment">// 得到一个毫秒级别的时间戳</span></span><br><span class="line">    System.out.println(date.getTime());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种写法比较麻烦一些, 可以<strong>使用</strong> <strong>import</strong>语句导入包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">// 得到一个毫秒级别的时间戳</span></span><br><span class="line">    System.out.println(date.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要使用 <code>java.util</code> 中的其他类, 可以使用<code> import java.util.*</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;<span class="comment">// .*相当于一个通配符，可以充当任何类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">// 得到一个毫秒级别的时间戳</span></span><br><span class="line">    System.out.println(date.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是更建议显式的指定要导入的类名，否则还是容易出现<strong>冲突</strong>的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// util 和 sql 中都存在一个 Date 这样的类, 此时就会出现歧义, 编译出错</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    System.out.println(date.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 编译出错</span></span><br><span class="line">Error:(<span class="number">5</span>, <span class="number">9</span>) java: 对Date的引用不明确</span><br><span class="line">java.sql 中的类 java.sql.Date 和 java.util 中的类 java.util.Date 都匹配</span><br></pre></td></tr></table></figure><p>在上面这种情况下，则需要使用完整的类名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    java.util.<span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Date();</span><br><span class="line">    System.out.println(date.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<strong>import static</strong>导入包中静态的方法和字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">    <span class="comment">// 静态导入的方式写起来更方便一些.</span></span><br><span class="line">    <span class="comment">// double result = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> sqrt(pow(x, <span class="number">2</span>) + pow(y, <span class="number">2</span>));</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>:</p><ul><li><p><code>import</code> 和 C++ 的<code> #include</code> 差别很大, C++ 必须 <code>#include</code> 来引入其他文件内容, 但是 Java 不需要</p></li><li><p><code>import</code> 只是为了写代码的时候更方便, <code>import</code> 更类似于 C++ 的 <code>namespace</code> 和 <code>using</code></p></li></ul><h3 id="Ⅲ、常见的包">Ⅲ、常见的包</h3><ul><li><p><code>java.lang</code>：系统常用基础类(String、Object),此包从JDK1.1后自动导入。</p></li><li><p><code>java.lang.reflflect</code>：java 反射编程包;</p></li><li><p><code>java.net</code>：进行网络编程开发包。</p></li><li><p><code>java.sql</code>：进行数据库开发的支持包。</p></li><li><p><code>java.util</code>：是java提供的工具程序包。(集合类等) <strong>非常重要</strong></p></li><li><p><code>java.io</code>：I/O编程开发包。</p></li></ul><h1>七、<code>static</code>成员</h1><p>使用前文中介绍的学生类实例化三个对象s1、s2、s3，每个对象都有自己特有的名字、性别，年龄，学分绩点等成员信息，这些信息就是对不同学生来进行描述的，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Li leilei&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">18</span>, <span class="number">3.8</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Han MeiMei&quot;</span>, <span class="string">&quot;女&quot;</span>, <span class="number">19</span>, <span class="number">4.0</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Jim&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">18</span>, <span class="number">2.6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305071630907.png" alt="image-20230507163021800"></p><p>假设三个同学是同一个班的，那么他们上课肯定是在同一个教室，那既然在同一个教室，那能否给类中再加一个成员变量，来保存同学上课时的教室呢？</p><p>答案是不行的，之前在<strong>Student</strong>类中定义的成员变量，每个对象中都会包含一份**(**称之为实例变量)，因为需要使用这些信息来描述具体的学生。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305091735579.png" alt="image-20230509173517457"></p><p><strong>而现在要表示学生上课的教室，这个教室的属性并不需要每个学生对象中都存储一份，而是需要让所有的学生来共享。</strong></p><p><strong>在Java中，被static修饰的成员，称之为静态成员，也可以称为类成员，其不属于某个具体的对象，是所有对象所共享的</strong>。</p><h2 id="1、static修饰成员变量">1、<code>static</code>修饰成员变量</h2><p><strong><code>static</code>修饰的成员变量，称为静态成员变量，静态成员变量最大的特性：不属于某个具体的对象，是所有对象所共享的 。</strong></p><blockquote><p>普通成员变量：在类的内部，方法的外部</p><p>静态成员变量：在类的内部，方法的外部，被<code>static</code>修饰了</p><p>局部变量：方法内部定义的变量</p></blockquote><p><strong>【静态成员变量特性】</strong></p><ul><li>静态成员不属于某个具体的对象，是类的属性，所有对象共享的，不存储在某个对象的空间中</li><li>既可以通过对象访问，也可以通过类名访问，但一般更推荐使用类名访问</li><li>类变量存储在方法区当中</li><li>生命周期伴随类的一生(即：随类的加载而创建，随类的卸载而销毁)</li></ul><p><strong>【静态成员的访问方式】</strong></p><ul><li>不建议通过对象的引用访问</li><li>建议通过<code>类名.</code>的方式进行访问</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;<span class="comment">//普通成员变量</span></span><br><span class="line">    <span class="keyword">public</span> String gender;<span class="comment">//普通成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;<span class="comment">//普通成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> score;<span class="comment">//普通成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">classRoom</span> <span class="operator">=</span> <span class="string">&quot;401&quot;</span>; <span class="comment">//静态成员变量</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 静态成员变量可以直接通过类名访问（说明静态成员变量并不属于对象！）</span></span><br><span class="line">    System.out.println(Student.classRoom);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Li leilei&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">18</span>, <span class="number">3.8</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Han MeiMei&quot;</span>, <span class="string">&quot;女&quot;</span>, <span class="number">19</span>, <span class="number">4.0</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Jim&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">18</span>, <span class="number">2.6</span>);</span><br><span class="line">    <span class="comment">// 也可以通过对象访问：但是classRoom是三个对象共享的，但是不建议这样去写。</span></span><br><span class="line">    System.out.println(s1.classRoom);</span><br><span class="line">    System.out.println(s2.classRoom);</span><br><span class="line">    System.out.println(s3.classRoom);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、static修饰成员方法">2、<code>static</code>修饰成员方法</h2><p>在Java中，<code>static</code>关键字也可以用来修饰方法，使得这些方法与类本身关联，而不是与类的具体对象关联。</p><p>这意味着你可以在不创建类的对象的情况下调用这些方法。以下是<code>static</code>修饰成员方法的一些关键点：</p><ol><li><p>不需要创建对象：<code>static</code>方法不需要创建类的对象就可以调用。你可以直接使用类名来调用它们，如<code>MyClass.staticMethod()</code>。</p></li><li><p>只能访问静态成员：<code>static</code>方法不能直接访问类中的非静态成员（变量和方法）。它们只能访问静态成员。</p></li><li><p>常用于工具类：<code>static</code>方法通常用于实现那些与类的状态无关的功能，例如工具类和帮助方法。</p></li></ol><p>下面是一个简单的例子来说明<code>static</code>修饰成员方法的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他成员变量和方法 ...</span></span><br><span class="line">    <span class="comment">// 使用 static 关键字修饰一个名为 classRoom 的成员变量，并赋值为 &quot;301&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">classRoom</span> <span class="operator">=</span> <span class="string">&quot;301&quot;</span>;</span><br><span class="line">    <span class="comment">// ... 其他成员变量和方法 ...</span></span><br><span class="line">    <span class="comment">// 定义一个名为 getClassRoom 的 static 方法，用于获取 classRoom 变量的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getClassRoom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> classRoom;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStudent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 直接通过Student类名调用 getClassRoom 方法</span></span><br><span class="line">        System.out.println(Student.getClassRoom());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们直接使用类名<code>Student</code>调用<code>getClassRoom()</code>方法，而不需要创建类的对象。</p><p><strong>【静态方法特性】</strong></p><ul><li><p>不属于某个具体的对象，是类方法</p></li><li><p>可以通过对象调用，也可以通过<code>类名.静态方法名(...)</code>方式调用，更推荐使用后者</p></li><li><p>不能在静态方法中访问任何非静态成员变量</p></li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getClassRoom</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> classRoom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译失败：Error:(35, 28) java: 无法从静态上下文中引用非静态 变量 this</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getClassRoom</span><span class="params">()</span>&#123;</span><br><span class="line">    age += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> classRoom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译失败：Error:(35, 9) java: 无法从静态上下文中引用非静态 变量 age</span></span><br></pre></td></tr></table></figure><ul><li>静态方法中不能调用任何非静态方法，因为非静态方法有this参数，在静态方法中调用时候无法传递this引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getClassRoom</span><span class="params">()</span>&#123;</span><br><span class="line">    doClass();</span><br><span class="line">    <span class="keyword">return</span> classRoom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译报错：Error:(35, 9) java: 无法从静态上下文中引用非静态 方法 doClass()</span></span><br></pre></td></tr></table></figure><h2 id="3、static成员变量初始化">3、<code>static</code>成员变量初始化</h2><p>注意：静态成员变量一般不会放在构造方法中来初始化，构造方法中初始化的是与对象相关的实例属性</p><p><strong>静态成员变量的初始化分为两种：就地初始化 和 静态代码块初始化</strong>。</p><p><strong>就地初始化：在定义时直接给出初始值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">classRoom</span> <span class="operator">=</span> <span class="string">&quot;301&quot;</span>; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态代码块初始化：静态代码块是一种特殊的代码结构，用于在类加载时初始化静态成员变量。它在类中使用<code>static</code>关键字定义，并由一对大括号（<code>&#123;&#125;</code>）包围。静态代码块在类加载时自动执行，且仅执行一次。</strong></p><h1>八、代码块</h1><h2 id="1、普通代码块">1、普通代码块</h2><p>普通代码块：定义在方法中的代码块。这种用法较少见</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#123; <span class="comment">//直接使用&#123;&#125;定义，普通方法块</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span> ;</span><br><span class="line">        System.out.println(<span class="string">&quot;x1 = &quot;</span> +x);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span> ;</span><br><span class="line">        System.out.println(<span class="string">&quot;x2 = &quot;</span> +x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">x1 = <span class="number">10</span></span><br><span class="line">x2 = <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="2、构造代码块">2、构造代码块</h2><p>构造代码块：定义在类中的代码块(不加修饰符)。也叫：<strong>实例代码块</strong>。</p><p><strong>构造代码块一般用于初始化实例成员变量</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="comment">//实例成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> score;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;I am Student init()!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例代码块</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">this</span>.sex = <span class="string">&quot;man&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;I am instance init()!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;name: &quot;</span>+name+<span class="string">&quot; age: &quot;</span>+age+<span class="string">&quot; sex: &quot;</span>+sex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        stu.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">I am instance <span class="title function_">init</span><span class="params">()</span>!</span><br><span class="line">I am Student <span class="title function_">init</span><span class="params">()</span>!</span><br><span class="line">name: bit age: <span class="number">12</span> sex: man</span><br></pre></td></tr></table></figure><h2 id="3、静态代码块">3、静态代码块</h2><p>使用<code>static</code>定义的代码块称为静态代码块。<strong>一般用于初始化静态成员变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">// 声明一些实例变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">// 声明一个静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String classRoom;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例代码块，用于初始化实例变量</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;bit&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">12</span>;</span><br><span class="line">        <span class="built_in">this</span>.gender = <span class="string">&quot;man&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am instance init()!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块，用于初始化静态变量</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        classRoom = <span class="string">&quot;bit306&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am static init()!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数，用于创建 Student 类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am Student init()!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建两个 Student 类的对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li>静态代码块不管生成多少个对象，其只会执行一次</li><li>静态成员变量是类的属性，因此是在JVM加载类时开辟空间并初始化的</li><li>如果一个类中包含多个静态代码块，在编译代码时，编译器会按照定义的先后次序依次执行(合并)</li><li>实例代码块只有在创建对象时才会执行</li></ul><h2 id="4、执行顺序">4、执行顺序</h2><p>在Java中，代码块、构造函数和静态代码块的执行顺序如下：</p><ol><li><p>静态代码块：在类加载时执行，且仅执行一次。静态代码块优先于其他成员的初始化执行，即使没有创建实例，也会执行静态代码块。</p></li><li><p>实例代码块：每次创建实例时都会执行。在实例化之前，实例代码块会在构造函数之前执行。</p></li><li><p>构造函数：构造函数会在实例代码块执行完毕后执行。</p></li></ol><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行实例代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Example</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行静态代码块</span><br><span class="line">执行实例代码块</span><br><span class="line">执行构造函数</span><br><span class="line">执行实例代码块</span><br><span class="line">执行构造函数</span><br></pre></td></tr></table></figure><p>从输出结果可以看出，静态代码块在类加载时只会执行一次；实例代码块和构造函数在每次创建实例时都会执行。</p><h1>九、对象的打印</h1><p>在Java中，如果你想打印一个对象的信息，可以使用<code>System.out.println()</code>方法，并将对象传递给它。当你这样做时，Java将自动调用对象的<code>toString()</code>方法，将其转换为一个字符串并打印出来。</p><blockquote><p>在Java中，每个对象都有一个默认的<code>toString()</code>方法，它返回一个包含类名和对象的内存地址的字符串。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 Person 的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 声明一些实例变量</span></span><br><span class="line">    String name;</span><br><span class="line">    String gender;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，用于创建 Person 类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, String gender, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 Person 类的对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jim&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">// 打印该对象，Java将自动调用对象的 toString() 方法</span></span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果：day20210829.Person@1b6d3586 </span></span><br></pre></td></tr></table></figure><p>如果想要默认打印对象中的属性该如何处理呢？</p><p>答案：重写<code>toString</code>方法，并在其中返回你想要的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 Person 的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 声明一些实例变量</span></span><br><span class="line">    String name;</span><br><span class="line">    String gender;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，用于创建 Person 类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, String gender, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 toString() 方法，返回一个包含对象属性的字符串</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + name + <span class="string">&quot;,&quot;</span> + gender + <span class="string">&quot;,&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 Person 类的对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jim&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">// 打印该对象，Java将自动调用对象的 toString() 方法</span></span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：[Jim,男,18]</span></span><br></pre></td></tr></table></figure><p><strong>【总结】</strong></p><p>如果我们没有覆盖<code>toString()</code>方法，Java将使用默认的<code>toString()</code>方法生成一个字符串，该字符串由类名、<code>@</code>符号和对象的内存地址组成。</p><p>例如，对于一个名为<code>Person</code>的类，它的默认<code>toString()</code>方法生成的字符串可能是<code>Person@1b6d3586</code>。</p><p>这并不是我们所期望的输出结果，因为它没有显示对象的属性。</p><p>为了让对象的属性默认被打印出来，我们可以覆盖<code>toString()</code>方法，并在其中返回一个包含对象属性的字符串。例如，假设我们有一个名为<code>Person</code>的类，其中包含了一些实例变量<code>name</code>、<code>gender</code>和<code>age</code>，那么我们可以在<code>Person</code>类中添加以下<code>toString()</code>方法来返回一个包含对象属性的字符串：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + name + <span class="string">&quot;,&quot;</span> + gender + <span class="string">&quot;,&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用<code>System.out.println()</code>方法并将一个<code>Person</code>对象传递给它时，Java将自动调用该对象的<code>toString()</code>方法，并打印出返回的字符串。例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="built_in">new</span> Person(&quot;Jim&quot;, &quot;男&quot;, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(person);</span><br></pre></td></tr></table></figure><p>输出结果将是<code>[Jim,男,18]</code>，它显示了<code>person</code>对象的属性。</p><p>需要注意的是，重写<code>toString()</code>方法是可选的，它不影响对象本身的行为，只是为了方便调试和输出。在编写代码时，我们可以根据需要决定是否要覆盖<code>toString()</code>方法。</p><h1>十、一些练习</h1><p><strong>1、下面代码的运行结果是（）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">  String s;</span><br><span class="line">  System.out.println(<span class="string">&quot;s=&quot;</span>+s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.代码编程成功，并输出”s=”</p><p>B.代码编译成功，并输出”s=null”</p><p>C.由于String s没有初始化，代码不能编译通过。</p><p>D.代码编译成功，但捕获到Null Point Exception异常</p><blockquote><p>答案：C</p><p>本题中的代码不能编译通过，因为在Java当中局部变量必须先初始化，后使用。所以此处编译不能通过！</p></blockquote><p><strong>2、阅读如下代码。 请问，对语句行 <code>test.hello()</code>描述正确的有（）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> NowCoder;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Test test=<span class="literal">null</span>;</span><br><span class="line">test.hello();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.能编译通过，并正确运行</p><p>B.因为使用了未初始化的变量，所以不能编译通过</p><p>C.以错误的方式访问了静态方法</p><p>D.能编译通过，但因变量为null，不能正常运行</p><blockquote><p>答案：A</p><p>hello方法被static修饰，是一个静态方法，调用静态方法不需要创建实例对象。</p><p>此时的<code>Test test=null;</code> 表示<code>test</code>这个引用不指向任何对象。所以此处可以正常访问。</p><p>如果hello方法没有加static修饰，那么这段代码必然会报错。</p><p>但是我们需要牢记，静态方法的正确访问方式<strong>应该是用过类型来访问</strong>。即：<code>Test.hello();</code></p></blockquote><p><strong>3、如下代码的输出结果是什么？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">aMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        i++; </span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>(); </span><br><span class="line">    test.aMethod(); </span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> test.aMethod();</span><br><span class="line">    System.out.println(j);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A. 0</p><p>B. 1</p><p>C. 2</p><p>D.编译失败</p><blockquote><p>答案：D</p><p><code>static int i = 0;</code>这段代码语句错了，因为他是在方法当中定义的变量。</p><p>在方法当中定义的变量是局部变量，而静态的变量属于类的变量。</p><p>静态变量随着类的加载而被创建，而局部变量是调用该方法的时候，才创建的。所以，此时两种变量的性质是冲突的。Java当中不允许定义局部的静态变量。</p></blockquote><p><strong>4、当你编译和运行下面的代码时，会出现下面选项中的哪种情况？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pvf</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> Paddy;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        System.out.println(Paddy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.编译时错误</p><p>B.编译通过并输出结果false</p><p>C.编译通过并输出结果true</p><p>D.编译通过并输出结果null</p><blockquote><p>答案：B</p><p>在Java当中，成员变量没有赋初值的时候，会有默认的初始值。基本类型是对应的0值。如：int是0，boolean是false,char类型是’\u0000’，引用类型是null，如String。</p></blockquote><p><strong>5、已知如下类说明：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">float</span> f=<span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> m=<span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> n=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">      </span><br><span class="line">    Test t=<span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下哪些在main函数中使用是正确的（）</p><p>A. <code>t.f = 3.0</code></p><p>B. <code>this.n</code></p><p>C. <code>Test.m</code></p><p>D. <code>Test.n</code></p><blockquote><p>答案：D</p><p>A：<code>f</code>是私有的（<code>private</code>），不能在类的外部直接访问。并且在Java中浮点数字面量默认被视为<code>double</code>，所以3.0是<code>double</code>类型，不能直接赋值给<code>float</code>类型变量<code>f</code>。应使用类型转换或者<code>float</code>类型字面量。</p><p>B：<code>this</code>关键字用于引用当前实例。在静态方法（如<code>main</code>方法）中，没有当前实例，因为静态方法属于类本身而非特定实例。因此，不能在静态方法中使用<code>this</code>关键字。</p><p>C：<code>m</code>是一个非静态成员变量，不能通过类名直接访问。要访问非静态成员变量，需要使用类的实例。</p><p>D：<code>n</code>是一个静态成员变量，可以通过类名直接访问。在<code>main</code>方法中使用<code>Test.n</code>是正确的。所以这个选项是正确的。</p></blockquote><p><strong>6、关于以下程序代码的说明正确的是()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HasStatic</span> &#123;<span class="comment">// 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">// 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;<span class="comment">// 3</span></span><br><span class="line"><span class="type">HasStatic</span> <span class="variable">hsl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HasStatic</span>();<span class="comment">// 4</span></span><br><span class="line">hsl.x++;<span class="comment">// 5</span></span><br><span class="line"><span class="type">HasStatic</span> <span class="variable">hs2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HasStatic</span>();<span class="comment">// 6</span></span><br><span class="line">hs2.x++;<span class="comment">// 7</span></span><br><span class="line">hsl = <span class="keyword">new</span> <span class="title class_">HasStatic</span>();<span class="comment">// 8</span></span><br><span class="line">hsl.x++;<span class="comment">// 9</span></span><br><span class="line">HasStatic.x--;<span class="comment">// 10</span></span><br><span class="line">System.out.println(<span class="string">&quot; x=&quot;</span> + x);<span class="comment">// 11</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A. 程序通过编译，输出结果为:x=102</p><p>B. 程序通过编译，输出结果为:x=103</p><p>C. 10行不能通过编译.因为x星私有静态变量</p><p>D. 5行不能通过编译.因为引用了私有静态变量</p><blockquote><p>答案：A</p><ol><li>本题中的静态成员变量x，属于类变量，只有一份。所有对x的操作针对的都是同一份。</li><li>静态成员变量的访问需要通过类名访问，这是正确的访问方式。本题中虽然使用了对象引用访问，但是不会报错，我们不建议这样访问，但不是错误，所以，不会编译报错。</li></ol><p>综合以上2点，得出结论：本题可以正常通过编译和运行，输出结果是102。</p></blockquote><p><strong>7、以下代码在编译和运行过程中会出现什么情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">TestDemo test=<span class="keyword">new</span> <span class="title class_">TestDemo</span>(<span class="number">88</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(test.count);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> TestDemo(<span class="type">int</span> a) &#123;</span><br><span class="line"></span><br><span class="line"> count=a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.编译运行通过，输出结果是88</p><p>B.编译时错误，<code>count</code>变量定义的是私有变量</p><p>C.编译时错误，<code>System.out.println</code>方法被调用时<code>test</code>没有被初始化</p><p>D.编译和执行时没有输出结果</p><blockquote><p>答案：A</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TestDemo</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestDemo</span>(<span class="number">88</span>);</span><br></pre></td></tr></table></figure><p>这段代码会先执行构造方法，将88的值，赋值给count，所以最终输出的值是88</p></blockquote><p><strong>8、在JAVA中，假设A有构造方法<code>A(int a)</code>，则在类A的其他构造方法中调用该构造方法和语句格式应该为（）</strong></p><p>A.<code>this.A(x)</code></p><p>B.<code>this(x)</code></p><p>C.<code>super(x)</code></p><p>D. <code>A(x)</code></p><blockquote><p>答案：B</p><p>this共有2种使用方式：</p><ul><li><p><code>this.data</code> 访问当前对象的实例成员变量</p></li><li><p><code>this.func()</code> 访问当前对象的实例成员方法</p></li><li><p><code>this(参数列表)</code> 访问当前对象的构造方法</p></li></ul><p>此处在当前类当中，调用构造方法<code>A(int a)</code>，使用<code>this(x);</code>的方式，所以选择B。</p><p>A：不能通过点号访问构造方法</p><p>C：<code>super(x)</code>，是初始化父类继承过来的那部分成员</p><p>D：缺少this</p></blockquote>]]></content>
    
    
    <summary type="html">JavaSE：类和对象，面向对象编程的基础</summary>
    
    
    
    <category term="笔记" scheme="https://www.zxhy.club/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://www.zxhy.club/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习之旅：方法</title>
    <link href="https://www.zxhy.club/posts/java05.html"/>
    <id>https://www.zxhy.club/posts/java05.html</id>
    <published>2023-05-07T07:38:23.000Z</published>
    <updated>2023-07-04T01:45:08.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>Java中的方法是一种在Java编程中非常常见的概念。</p><p>我们可以将方法看作是一种可重复使用的代码块，类似于生活中的工具。就像我们在日常生活中会使用各种各样的工具来完成不同的任务一样，我们在编程中也可以使用方法来完成各种不同的操作。</p><h1 id="二、方法的概念和使用"><a href="#二、方法的概念和使用" class="headerlink" title="二、方法的概念和使用"></a>二、方法的概念和使用</h1><h2 id="1、什么是方法"><a href="#1、什么是方法" class="headerlink" title="1、什么是方法"></a>1、什么是方法</h2><p>方法就是一个代码片段.。类似于 C 语言中的 “函数”。方法允许我们将代码进行组织和封装，这有助于提高代码的可读性、可重用性和可维护性。方法可以接受参数，执行一系列操作，并返回一个结果。</p><p>方法存在的意义：</p><ul><li><p>是能够模块化的组织代码(当代码规模比较复杂的时候).</p></li><li><p>做到代码被重复使用, 一份代码可以在多个位置使用.</p></li><li><p>让代码更好理解更简单.</p></li><li><p>直接调用现有方法开发, 不必重复造轮子</p></li></ul><h2 id="2、方法的定义"><a href="#2、方法的定义" class="headerlink" title="2、方法的定义"></a>2、方法的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名称(方法参数列表) &#123;</span><br><span class="line">    <span class="comment">// 方法体（method body）</span></span><br><span class="line">    <span class="comment">// 包含实现特定任务的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：写一个方法求两个整数的和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">addNumbers</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> num1 + num2;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>【注意事项】</strong></p><ul><li><p>修饰符：现阶段直接使用<code>public static</code> 固定搭配</p></li><li><p>返回值类型：如果方法有返回值，返回值类型必须要与返回的实体类型一致，如果没有返回值，必须写成<code>void</code></p></li><li><p>方法名字：采用小驼峰命名</p></li><li><p>参数列表：如果方法没有参数，()中什么都不写，如果有参数，需指定参数类型，多个参数之间使用逗号隔开</p></li><li><p>方法体：方法内部要执行的语句</p></li><li><p>在java当中，方法必须写在类当中</p></li><li><p>在java当中，方法不能嵌套定义</p></li><li><p>在java当中，没有方法声明一说（C语言需要进行方法声明）</p></li></ul><h2 id="3、方法调用的过程"><a href="#3、方法调用的过程" class="headerlink" title="3、方法调用的过程"></a>3、方法调用的过程</h2><p><strong>调用方法—-&gt;传递参数—-&gt;找到方法地址—-&gt;执行被调方法的方法体—-&gt;被调方法结束返回—-&gt;回到主调方法往下执行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;第一次调用方法之前&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> add(a, b);</span><br><span class="line">            System.out.println(<span class="string">&quot;第一次调用方法之后&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;ret = &quot;</span> + ret);</span><br><span class="line">            System.out.println(<span class="string">&quot;第二次调用方法之前&quot;</span>);</span><br><span class="line">            ret = add(<span class="number">30</span>, <span class="number">50</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;第二次调用方法之后&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;ret = &quot;</span> + ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;调用方法中 x = &quot;</span> + x + <span class="string">&quot; y = &quot;</span> + y);</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202306281117364.png" alt="image-20230628111709248"></p><p>方法的调用，每次都会在栈上开辟内存！</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202306281126853.png" alt="image-20230628112640799"></p><h2 id="4、实参和形参的关系"><a href="#4、实参和形参的关系" class="headerlink" title="4、实参和形参的关系"></a>4、实参和形参的关系</h2><p>方法的形参相当于数学函数中的自变量</p><script type="math/tex; mode=display">1 + 2 + 3 + … + n的公式为：sum(n) = n*（n+1）/ 2</script><p><strong>Java中方法的形参就相当于sum函数中的自变量n，用来接收sum函数在调用时传递的值的。</strong>形参的名字可以随意</p><p>取，对方法都没有任何影响，<strong>形参只是方法在定义时需要借助的一个变量，用来保存方法在调用时传递过来的值</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 2和3是实参，在调用时传给形参a和b</span></span><br></pre></td></tr></table></figure><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202306281139751.png" alt="image-20230628113917705"></p><p>注意：<strong>在Java中，实参的值永远都是拷贝到形参中，形参和实参本质是两个实体</strong></p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMethod</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    swap(a, b);</span><br><span class="line">    System.out.println(<span class="string">&quot;main: a = &quot;</span> + a + <span class="string">&quot; b = &quot;</span> + b);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp;</span><br><span class="line">    System.out.println(<span class="string">&quot;swap: x = &quot;</span> + x + <span class="string">&quot; y = &quot;</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">swap: x = <span class="number">20</span> y = <span class="number">10</span></span><br><span class="line">main: a = <span class="number">10</span> b = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>在<code>swap</code>函数交换之后，形参x和y的值发生了改变，但是main方法中a和b还是交换之前的值，即没有交换成功。那么为什么呢？</p><p>实参a和b是main方法中的两个变量，其空间在main方法的栈(一块特殊的内存空间)中，而形参x和y是swap方法中的两个变量，x和y的空间在swap方法运行时的栈中。因此：<strong>实参a和b 与 形参x和y是两个没有任何关联性的变量，在swap方法调用时，只是将实参a和b中的值拷贝了一份传递给了形参x和y，因此对形参x和y操作不会对实参a和b产生任何影响。</strong>对于<strong>基础类型</strong>来说, 形参相当于实参的拷贝，即 <strong>传值调用</strong>。</p><p>【<strong>解决办法</strong>】: 传引用类型参数 (例如使用数组来解决这个问题)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line">    arr[<span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、方法重载"><a href="#三、方法重载" class="headerlink" title="三、方法重载"></a>三、方法重载</h1><h2 id="1、函数重载的概念"><a href="#1、函数重载的概念" class="headerlink" title="1、函数重载的概念"></a>1、函数重载的概念</h2><p>在自然语言中，经常会出现“一词多义”的现象，比如：“好人”。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202306281221563.png" alt="image-20230628122141474"></p><p>在自然语言中，一个词语如果有多重含义，那么就说该词语被重载了，具体代表什么含义需要结合具体的场景。在Java中方法也是可以重载的。</p><p><strong>在Java中，如果多个方法的名字相同，参数列表不同，则称该几种方法被重载了</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMethod</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用add(int, int)</span></span><br><span class="line">    add(<span class="number">1.5</span>, <span class="number">2.5</span>); <span class="comment">// 调用add(double, double)</span></span><br><span class="line">    add(<span class="number">1.5</span>, <span class="number">2.5</span>, <span class="number">3.5</span>); <span class="comment">// 调用add(double, double, double)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> z)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y + z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>【注意】</strong></p><ul><li><p>方法名必须相同</p></li><li><p>参数列表必须不同(参数的个数不同、参数的类型不同、类型的次序必须不同)</p></li><li><p>与返回值类型是否相同无关</p></li><li><strong>两个方法如果仅仅只是因为返回值类型不同，是不能构成重载的</strong></li><li>编译器在编译代码时，会对实参类型进行推演，根据推演的结果来确定调用哪个方法</li></ul><h2 id="2、方法签名"><a href="#2、方法签名" class="headerlink" title="2、方法签名"></a>2、方法签名</h2><p>在同一个作用域中不能定义两个相同名称的标识符。</p><p>比如：方法中不能定义两个名字一样的变量，<strong>那为什么类中就可以定义方法名相同的方法呢？</strong></p><p>方法签名即：经过编译器编译修改过之后方法最终的名字。具体方式：<strong>方法全路径名+参数列表+返回值类型，构成方法完整的名字。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMethod</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">add(<span class="number">1.5</span>, <span class="number">2.5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码经过编译之后，然后使用JDK自带的javap反汇编工具查看，具体操作：</p><ol><li><p>先对工程进行编译生成.class字节码文件</p></li><li><p>在控制台中进入到要查看的.class所在的目录</p></li><li><p>输入：javap -v 字节码文件名字即可</p></li></ol><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202306281253398.png" alt="image-20230628125355312"></p><p>方法签名中的一些特殊符号说明：</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202306281254618.png" alt="image-20230628125419557"></p>]]></content>
    
    
    <summary type="html">JavaSE：Java中的方法</summary>
    
    
    
    <category term="笔记" scheme="https://www.zxhy.club/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://www.zxhy.club/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习之旅：分支循环</title>
    <link href="https://www.zxhy.club/posts/java04.html"/>
    <id>https://www.zxhy.club/posts/java04.html</id>
    <published>2023-05-07T05:28:23.000Z</published>
    <updated>2023-05-07T05:35:07.979Z</updated>
    
    <content type="html"><![CDATA[<h1>一、前言</h1><p>在Java编程中，分支语句和循环语句是实现程序流程控制的重要工具，它们可以根据不同的条件执行不同的代码块，或者多次执行同一段代码。合理使用分支语句和循环语句可以使程序结构更加清晰、代码更加简洁、逻辑更加严谨，同时也可以提高程序的执行效率和性能。在本文中，我们将会详细介绍Java中分支循环语句。</p><h1>二、顺序结构</h1><p>在Java编程语言中，顺序结构是一种最简单的程序结构。它指的是程序按照代码编写的顺序，一行一行地执行，从上往下依次执行，不会跳过任何一行代码。</p><p>在顺序结构中，每一条语句都会在前一条语句执行完成之后才会执行。这种执行方式非常直观，也很容易理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure><p>如果调整代码的书写顺序, 则执行顺序也发生变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">aaa</span><br><span class="line">ccc</span><br><span class="line">bbb</span><br></pre></td></tr></table></figure><h1>三、分支结构</h1><p>在Java编程语言中，分支语句是一种根据条件选择不同执行路径的程序结构。Java提供了多种分支语句，包括if语句、if-else语句、switch语句。</p><h2 id="1、if语句">1、if语句</h2><h3 id="Ⅰ、语法格式1">Ⅰ、语法格式1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line"><span class="comment">// 语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果布尔表达式结果为true，执行if中的语句，否则不执行。</p><p>比如：小明，如果这次考试考到90分或以上，给你奖励一个鸡腿。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">92</span>;</span><br><span class="line"><span class="keyword">if</span>(score &gt;= <span class="number">90</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;吃个大鸡腿!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ⅱ、语法格式2">Ⅱ、语法格式2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line"><span class="comment">// 语句1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 语句2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果布尔表达式结果为true，则执行if中语句，否则执行else中语句。</p><p>比如：小明，如果这次考到90分以上，给你奖励一个大鸡腿，否则奖你一个大嘴巴子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">92</span>;</span><br><span class="line"><span class="keyword">if</span>(score &gt;= <span class="number">90</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;吃个大鸡腿!!!&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;挨大嘴巴子!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ⅲ、语法格式3">Ⅲ、语法格式3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">// 语句1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式<span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">// 语句2</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 语句3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表达式1成立，执行语句1，否则表达式2成立，执行语句2，否则执行语句3</p><p>比如：考虑到学生自尊，不公开分数排名，因此：</p><p>分数在 [90, 100] 之间的，为优秀，分数在 [80, 90) 之前的，为良好，分数在 [70, 80) 之间的，为中等，分数在 [60, 70) 之间的，为及格，分数在 [ 0, 60) 之间的，为不及格，错误数据。按照上述办法通知学生成绩。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(score &gt;= <span class="number">90</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">80</span> &amp;&amp; score &lt; <span class="number">90</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">70</span> &amp;&amp; score &lt; <span class="number">80</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;中等&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">60</span> &amp;&amp; score &lt; <span class="number">70</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">0</span> &amp;&amp; score &lt; <span class="number">60</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;错误数据&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、switch语句">2、switch语句</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 执行语句块1</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">        <span class="comment">// 执行语句块2</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// more cases...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 执行默认语句块</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行流程：</strong></p><ul><li><p>先计算表达式的值</p></li><li><p>和<code>case</code>依次比较，一旦有响应的匹配就执行该项下的语句，直到遇到<code>break</code>时结束</p></li><li><p>当表达式的值没有与所列项匹配时，执行<code>default</code></p></li></ul><p><strong>代码示例</strong>： 根据 day 的值输出星期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(day) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;星期二&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;星期三&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;星期四&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;星期五&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;星期六&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;星期日&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;输入有误&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【<strong>注意事项</strong>】</p><ul><li><p>多个case后的常量值不可以重复</p></li><li><p>switch的括号内只能是以下类型的表达式：</p><ul><li><p>基本类型：byte、char、short、int，注意不能是long类型</p></li><li><p>引用类型：String常量串、枚举类型</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">switch</span>(num) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1.0</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;hehe&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2.0</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译出错</span></span><br><span class="line">Test.java:<span class="number">4</span>: 错误: 不兼容的类型: 从<span class="type">double</span>转换到<span class="type">int</span>可能会有损失</span><br><span class="line"><span class="keyword">switch</span>(num) &#123;</span><br><span class="line">^</span><br><span class="line"> <span class="number">1</span> 个错误</span><br></pre></td></tr></table></figure><ul><li>break 不要遗漏, 否则会失去 “多分支选择” 的效果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(day) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line"><span class="comment">// break;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;星期二&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">星期一</span><br><span class="line">星期二</span><br></pre></td></tr></table></figure><ul><li>switch 不能表达复杂的条件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如: 如果 num 的值在 10 到 20 之间, 就打印 hehe</span></span><br><span class="line"><span class="comment">// 这样的代码使用 if 很容易表达, 但是使用 switch 就无法表示.</span></span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">10</span> &amp;&amp; num &lt; <span class="number">20</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hehe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>switch 虽然支持嵌套, <strong>但是很丑</strong>，一般不推荐</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> y = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">switch</span>(y) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;hehe&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>四、循环结构</h1><h2 id="1、while循环">1、while循环</h2><h3 id="Ⅰ、基本语法格式">Ⅰ、基本语法格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件)&#123;</span><br><span class="line">循环语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环条件为 true, 则执行循环语句; 否则结束循环</p><p><strong>比如：计算 5 的阶乘</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (n &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">    result *= n;</span><br><span class="line">    n++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(num);</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure><p><strong>比如：计算 1! + 2! + 3! + 4! + 5!</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 外层循环负责求阶乘的和</span></span><br><span class="line"><span class="keyword">while</span> (num &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">factorResult</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 里层循环负责完成求阶乘的细节.</span></span><br><span class="line">    <span class="keyword">while</span> (tmp &lt;= num) &#123;</span><br><span class="line">        factorResult *= tmp;</span><br><span class="line">        tmp++;</span><br><span class="line">    &#125;</span><br><span class="line">    sum += factorResult;</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;sum = &quot;</span> + sum);</span><br></pre></td></tr></table></figure><p>这里我们发现, 当一个代码中带有多重循环的时候, 代码的复杂程度就大大提高了. 而比较复杂的代码就更容易出错，后面我们会采用更简单的办法来解决这个问题</p><h3 id="Ⅱ、注意事项">Ⅱ、注意事项</h3><ul><li><p>和 if 类似, while 下面的语句可以不写 { } , 但是不写的时候只能支持一条语句. 建议还是加上 { }</p></li><li><p>和 if 类似, while 后面的 { 建议和 while 写在同一行.</p></li><li><p>和 if 类似, while 后面不要多写 分号, 否则可能导致循环不能正确执行.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (num &lt;= <span class="number">10</span>); &#123;</span><br><span class="line">System.out.println(num);</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">[无任何输出, 程序死循环]</span><br></pre></td></tr></table></figure><p>此时 <code>;</code> 为<code>while</code>的语句体(这是一个空语句), 实际的 { } 部分和循环无关. 此时循环条件 <code>num &lt;= 10</code> 恒成立, 导致代码死循环了。</p><h3 id="Ⅲ、break">Ⅲ、break</h3><p><code>break</code> 的功能是让循环提前结束</p><p><strong>代码示例</strong>: 找到 100 - 200 中第一个 3 的倍数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">while</span> (num &lt;= <span class="number">200</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;找到了 3 的倍数, 为:&quot;</span> + num);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">找到了 <span class="number">3</span> 的倍数, 为:<span class="number">102</span></span><br></pre></td></tr></table></figure><p>执行到 <code>break</code> 就会让循环结束</p><h3 id="Ⅳ、-continue">Ⅳ、 continue</h3><p><code>continue</code>是一种用于跳过当前循环中剩余的语句并进入下一次循环的关键字。它通常用于在循环中跳过某些条件不符合的代码块，从而提高程序效率。</p><p>当在循环体内使用<code>continue</code>语句时，会立即跳过该循环体内剩余的语句，并开始下一次循环，直到循环结束或者遇到<code>break</code>语句为止。</p><p><strong>代码示例</strong>: 找到 100 - 200 中第一个 3 的倍数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">while</span> (num &lt;= <span class="number">200</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">num++; <span class="comment">// 这里的 ++ 不要忘记! 否则会死循环.</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;找到了 3 的倍数, 为:&quot;</span> + num);</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行到<code> continue</code> 语句的时候, 就会立刻进入下次循环(判定循环条件), 从而不会执行到下方的打印语句。</p><p>需要注意的是，<code>continue</code>语句只会跳过当前循环的剩余语句，而不是跳出整个循环。如果需要在循环中完全跳过某些情况，可以使用if语句或者其他的条件语句。</p><h2 id="2、for循环">2、for循环</h2><h3 id="Ⅰ、基本语法格式-2">Ⅰ、基本语法格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式①;布尔表达式②;表达式③)&#123;</span><br><span class="line">表达式④;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>表达式1: 用于初始化循环变量初始值设置，在循环最开始时执行，且只执行一次</p></li><li><p>表达式2: 循环条件，满则循环继续，否则循环结束</p></li><li><p>表达式3: 循环变量更新方式</p></li></ul><p>【<strong>执行过程</strong>】</p><p>①②③④—&gt;②③④—&gt;②③④—&gt;②③④—&gt;②③④—&gt;②③④—&gt;…—&gt;②为false，循环结束。</p><p><strong>比如：计算 5 的阶乘</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">result *= i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br></pre></td></tr></table></figure><p><strong>比如：计算 1! + 2! + 3! + 4! + 5!</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">  tmp *= j;</span><br><span class="line">    &#125;</span><br><span class="line">sum += tmp;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;sum = &quot;</span> + sum);</span><br></pre></td></tr></table></figure><h3 id="Ⅱ、注意事项-2">Ⅱ、注意事项</h3><p>(和while循环类似)</p><ul><li><p>和 if 类似, for 下面的语句可以不写 { } , 但是不写的时候只能支持一条语句. 建议还是加上 { }</p></li><li><p>和 if 类似, for 后面的 { 建议和 while 写在同一行.</p></li><li><p>和 if 类似, for 后面不要多写 分号, 否则可能导致循环不能正确执行.</p></li><li><p>和while循环一样，结束单趟循环用continue，结束整个循环用break</p></li></ul><h2 id="3、do-while循环">3、do-while循环</h2><h3 id="Ⅰ、基本语法格式-3">Ⅰ、基本语法格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">循环语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件);</span><br></pre></td></tr></table></figure><p><code>do-while</code>循环是一种重复执行特定代码块的结构，与<code>for</code>和<code>while</code>循环不同的是，它先执行一次循环体，再根据循环条件决定是否继续执行循环。</p><p>下面是一个使用<code>do-while</code>循环的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>在这个示例中，先初始化变量<code>i</code>的值为0，然后执行循环体，输出变量i的值，然后将<code>i</code>自增1。执行完一次循环体后，再根据条件<code>i &lt; 10</code>决定是否继续执行循环。如果条件为<code>true</code>，则继续执行循环体；否则，跳出循环体。</p><p>需要注意的是，<code>do-while</code>循环至少会执行一次循环体，即使循环条件一开始就为<code>false</code>。这与<code>while</code>循环的执行方式不同，<code>while</code>循环在循环条件一开始就为<code>false</code>时，不会执行任何循环体。总之，<code>do-while</code>循环是Java中一种与<code>for</code>和<code>while</code>循环不同的重复执行代码块的结构，它先执行一次循环体，再根据循环条件决定是否继续执行循环。</p><h3 id="Ⅲ、注意事项">Ⅲ、注意事项</h3><ul><li><p><code>do-while</code> 循环最后的分号不要忘记</p></li><li><p>一般 <code>do-while</code> 很少用到, 更推荐使用 <code>for</code> 和 <code>while</code></p></li></ul><h1>五、猜数字游戏</h1><h2 id="1、输入输出">1、输入输出</h2><h3 id="Ⅰ、输出到控制台">Ⅰ、输出到控制台</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(msg); <span class="comment">// 输出一个字符串, 带换行</span></span><br><span class="line">System.out.print(msg); <span class="comment">// 输出一个字符串, 不带换行</span></span><br><span class="line">System.out.printf(format, msg); <span class="comment">// 格式化输出</span></span><br></pre></td></tr></table></figure><ul><li><p><code>println</code> 输出的内容自带 \n, <code>print</code> 不带 \n</p></li><li><p><code>printf</code> 的格式化输出方式和 C 语言的 <code>printf</code> 是基本一致的</p></li></ul><h3 id="Ⅱ、从键盘上输入">Ⅱ、从键盘上输入</h3><p><strong>使用</strong> <strong>Scanner</strong> <strong>读取字符串/整数/浮点数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner; <span class="comment">// 需要导入 util 包</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入你的姓名：&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入你的年龄：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入你的工资：&quot;</span>);</span><br><span class="line"><span class="type">float</span> <span class="variable">salary</span> <span class="operator">=</span> sc.nextFloat();</span><br><span class="line">System.out.println(<span class="string">&quot;你的信息如下：&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;姓名: &quot;</span>+name+<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;年龄：&quot;</span>+age+<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;工资：&quot;</span>+salary);</span><br><span class="line">sc.close(); <span class="comment">// 注意, 要记得调用关闭方法</span></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">请输入你的姓名：</span><br><span class="line">张三</span><br><span class="line">请输入你的年龄：</span><br><span class="line"><span class="number">18</span></span><br><span class="line">请输入你的工资：</span><br><span class="line"><span class="number">1000</span></span><br><span class="line">你的信息如下：</span><br><span class="line">姓名: 张三</span><br><span class="line">年龄：<span class="number">18</span></span><br><span class="line">工资：<span class="number">1000.0</span></span><br></pre></td></tr></table></figure><p><strong>使用</strong> <strong>Scanner</strong> <strong>循环读取</strong> <strong>N</strong> <strong>个数字，并求取其平均值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (sc.hasNextInt()) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">    sum += tmp;</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;sum = &quot;</span> + sum);</span><br><span class="line">System.out.println(<span class="string">&quot;avg = &quot;</span> + sum / num);</span><br><span class="line">sc.close();</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">40.0</span></span><br><span class="line"><span class="number">50.5</span></span><br><span class="line">^<span class="type">Z</span></span><br><span class="line"><span class="variable">sum</span> <span class="operator">=</span> <span class="number">150.5</span></span><br><span class="line">avg = <span class="number">30.1</span></span><br></pre></td></tr></table></figure><p><code>sc.close()</code>是<code>Scanner</code>类中的一个方法，用于关闭<code>Scanner</code>对象并释放与其关联的资源。调用这个方法可以确保程序在结束时释放<code>Scanner</code>对象和其它资源，以便下次使用时不会出现问题。</p><h2 id="2、随机数生成">2、随机数生成</h2><p>在Java编程语言中，随机生成0~100之间的随机数可以使用Java标准库中的<code>java.util.Random</code>类来实现。其中，<code>Random</code>类的<code>nextInt()</code>方法可以用于生成指定范围内的随机整数。</p><p>下面是一个示例代码，演示如何使用<code>Random</code>类生成0~100之间的随机整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> rand.nextInt(<span class="number">100</span>) + <span class="number">1</span>; <span class="comment">// 生成1~100之间的随机整数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;随机数是：&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先创建了一个<code>Random</code>对象<code>rand</code>，然后使用<code>nextInt()</code>方法生成0~100之间的随机整数，最后将生成的随机数输出到控制台。</p><p>需要注意的是，<code>nextInt()</code>方法返回的随机数范围是从0开始，不包括上限，因此生成的随机数可能是0~99之间的整数。为了包含100和1，我们应该在生成的随机数后面再加上1。</p><h2 id="3、游戏实现">3、游戏实现</h2><p><strong>游戏规则</strong></p><blockquote><p>系统自动生成一个随机整数(1-100), 然后由用户输入一个猜测的数字. 如果输入的数字比该随机数小, 提示 “低了”, 如果输入的数字比该随机数大, 提示 “高了” , 如果输入的数字和随机数相等, 则提示 “猜对了” 。</p></blockquote><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(); <span class="comment">// 默认随机种子是系统时间</span></span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">toGuess</span> <span class="operator">=</span> random.nextInt(<span class="number">100</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// System.out.println(&quot;toGuess: &quot; + toGuess);</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要输入的数字: (1-100)&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (num &lt; toGuess) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;低了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; toGuess) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;高了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猜对了&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sc.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">JavaSE：Java中的分支循环结构</summary>
    
    
    
    <category term="笔记" scheme="https://www.zxhy.club/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://www.zxhy.club/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习之旅：运算符</title>
    <link href="https://www.zxhy.club/posts/java03.html"/>
    <id>https://www.zxhy.club/posts/java03.html</id>
    <published>2023-05-06T13:34:23.000Z</published>
    <updated>2023-05-06T13:38:24.103Z</updated>
    
    <content type="html"><![CDATA[<h1>一、前言</h1><p>作为Java编程中最基本的语法元素之一，运算符在编写程序时扮演着至关重要的角色。</p><p>运算符被用于执行各种数学和逻辑运算，以及比较操作，运算符的使用可以使代码更加简洁、易读和高效。在本文中，我们将会详细介绍Java中常见的运算符，并提供一些示例代码来更好地理解和掌握这些运算符的使用方法。</p><h1>二、运算符的介绍</h1><p>运算符是一种特殊符号，用于在程序中进行数学、逻辑或位运算。它们可以用于执行不同类型的操作。</p><p>例如：加、减、乘、除、等于、不等于、逻辑与、逻辑或、按位与、按位或等。在Java中，运算符通常用于操作变量，可以帮助程序员实现各种复杂的计算和逻辑处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">a + b;</span><br><span class="line">a &lt; b;</span><br></pre></td></tr></table></figure><p>上述 <code>+</code> 和 <code>&lt;</code> 等就是运算符，即：对操作数进行操作时的符号，不同运算符操作的含义不同。</p><p>作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。Java中运算符可分为以下：</p><ul><li>算术运算符(<code>+ - * / %</code>)</li><li>关系运算符(<code>&lt; &gt; ==</code>)</li><li>逻辑运算符</li><li>位移位运算符</li><li>条件运算符</li></ul><h1>三、算术运算符</h1><h2 id="1、四则运算符">1、四则运算符</h2><p>四则运算是指加、减、乘、除、取余这四种基本算术运算。在Java中，使用以下运算符进行四则运算：</p><ol><li>加法运算符（+）：将两个数相加。</li><li>减法运算符（-） ：将两个数相减。</li><li>乘法运算符（*）：将两个数相乘。</li><li>除法运算符（/） ：将两个数相除，结果为商。</li><li>取余运算符  (%)  ：求两个数相除后的余数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(a + b); <span class="comment">// 30</span></span><br><span class="line">System.out.println(a - b); <span class="comment">// 10</span></span><br><span class="line">System.out.println(a * b); <span class="comment">// 200</span></span><br><span class="line">System.out.println(a / b); <span class="comment">// 2</span></span><br><span class="line">System.out.println(a % b); <span class="comment">// 0 ---&gt;模运算相当于数学中除法的余数</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>都是二元运算符，使用时必须要有左右两个操作数</p></li><li><p><code>int / int </code>结果还是int类型，而且会向下取整</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 在数学中应该是1.5 但是在Java中输出结果为1 会向下取整，即小数点之后全部舍弃掉了</span></span><br><span class="line">System.out.println(a / b);</span><br><span class="line"><span class="comment">// 如果要得到数学中的结果，可以使用如下方式</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> a*<span class="number">1.0</span> / b;</span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure><ul><li>做除法和取模时，右操作数不能为0</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">System.out.println(a / b)</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ArithmeticException: / by zero</span><br><span class="line">at Test.main(Test.java:<span class="number">5</span>)</span><br></pre></td></tr></table></figure><ul><li>在Java中，取余运算符可以应用于整数和浮点数。当运算数都是整数时，结果也是整数，当运算数包含浮点数时，结果是浮点数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">11.5</span> % <span class="number">2.0</span>);</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="number">1.5</span></span><br></pre></td></tr></table></figure><ul><li>两侧操作数类型不一致时，向类型大的提升</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">1</span>+<span class="number">0.2</span>); </span><br><span class="line"><span class="comment">// +的左侧是int，右侧是double，在加之前int被提升为double</span></span><br><span class="line"><span class="comment">// 故：输出1.2</span></span><br></pre></td></tr></table></figure><h2 id="2、增量运算符">2、增量运算符</h2><p>该种类型运算符操作完成后，会将操纵的结果赋值给左操作数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">a += <span class="number">2</span>; <span class="comment">// 相当于 a = a + 2</span></span><br><span class="line">System.out.println(a); <span class="comment">// 输出3</span></span><br><span class="line">a -= <span class="number">1</span>; <span class="comment">// 相当于 a = a - 1</span></span><br><span class="line">System.out.println(a); <span class="comment">// 输出2</span></span><br><span class="line">a *= <span class="number">3</span>; <span class="comment">// 相当于 a = a * 3</span></span><br><span class="line">System.out.println(a); <span class="comment">// 输出6</span></span><br><span class="line">a /= <span class="number">3</span>; <span class="comment">// 相当于 a = a / 3</span></span><br><span class="line">System.out.println(a); <span class="comment">// 输出2</span></span><br><span class="line">a %= <span class="number">3</span>; <span class="comment">// 相当于 a = a % 2</span></span><br><span class="line">System.out.println(a); <span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure><p>注意：只有变量才能使用该运算符，常量不能使用。</p><h2 id="3、自增、自减运算符">3、自增、自减运算符</h2><p>自增运算符++：是给变量的值+1</p><p>自减运算符–：是给变量的值-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">a++; <span class="comment">// 后置++ 表示给a的值加1，此时a的值为2</span></span><br><span class="line">System.out.println(a++); <span class="comment">// 注意：后置++是先使用变量原来值，表示式结束时给变量+1，因此输出2</span></span><br><span class="line">System.out.println(a); <span class="comment">// 输出3</span></span><br><span class="line">++a; <span class="comment">// 前置++ 表示给a的值加1</span></span><br><span class="line">System.out.println(++a); <span class="comment">// 注意：前置++是先给变量+1，然后使用变量中的值，因此输出5</span></span><br><span class="line">System.out.println(a); <span class="comment">// 输出5</span></span><br><span class="line"><span class="comment">// --操作符给操作-1，与++含义类似</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>如果单独使用，【前置++】和【后置++】没有任何区别</p></li><li><p>如果混合使用，【前置++】先+1，然后使用变量+1之后的值，【后置++】先使用变量原来的值，表达式结束时给变量+1</p></li><li><p>只有变量才能使用自增/自减运算符，常量不能使用，因为常量不允许被修改</p></li></ul><h1>四、关系运算符</h1><p>关系运算符主要有六个: <code>== != &lt; &gt; &lt;= &gt;= </code>，其计算结果是 true 或者 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 注意：在Java中 = 表示赋值，要与数学中的含义区分</span></span><br><span class="line"><span class="comment">// 在Java中 == 表示相等</span></span><br><span class="line">System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line">System.out.println(a != b); <span class="comment">// true</span></span><br><span class="line">System.out.println(a &lt; b); <span class="comment">// true</span></span><br><span class="line">System.out.println(a &gt; b); <span class="comment">// false</span></span><br><span class="line">System.out.println(a &lt;= b); <span class="comment">// true</span></span><br><span class="line">System.out.println(a &gt;= b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>注意：当需要多次判断时，不能连着写，比如：3 &lt; a &lt; 5，Java程序与数学中是有区别的</p><h1>五、逻辑运算符</h1><p>逻辑运算符主要有三个: <code>&amp;&amp;</code> <code>||</code> <code> !</code> ，运算结果都是 boolean类型。</p><h2 id="1、逻辑与">1、逻辑与 <code>&amp;&amp;</code></h2><p>语法规则：<code>表达式1 &amp;&amp; 表达式2</code>，左右表达式必须是boolean类型的结果。</p><p>相当于现实生活中的且，比如：如果是学生，并且 带有学生证 才可以享受半票。两个表达式都为真，结果才是真，只要有一个是假，结果就是假。</p><table><thead><tr><th style="text-align:center">表达式1</th><th style="text-align:center">表达式2</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">真</td><td style="text-align:center">真</td><td style="text-align:center">真</td></tr><tr><td style="text-align:center">真</td><td style="text-align:center">假</td><td style="text-align:center">假</td></tr><tr><td style="text-align:center">假</td><td style="text-align:center">真</td><td style="text-align:center">假</td></tr><tr><td style="text-align:center">假</td><td style="text-align:center">假</td><td style="text-align:center">假</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">System.out.println(a == <span class="number">1</span> &amp;&amp; b == <span class="number">2</span>); <span class="comment">// 左为真 且 右为真 则结果为真</span></span><br><span class="line">System.out.println(a == <span class="number">1</span> &amp;&amp; b &gt; <span class="number">100</span>); <span class="comment">// 左为真 但 右为假 则结果为假</span></span><br><span class="line">System.out.println(a &gt; <span class="number">100</span> &amp;&amp; b == <span class="number">2</span>); <span class="comment">// 左为假 但 右为真 则结果为假</span></span><br><span class="line">System.out.println(a &gt; <span class="number">100</span> &amp;&amp; b &gt; <span class="number">100</span>); <span class="comment">// 左为假 且 右为假 则结果为假</span></span><br></pre></td></tr></table></figure><h2 id="2、逻辑或">2、逻辑或<code>||</code></h2><p>语法规则：<code>表达式1 || 表达式2</code>，左右表达式必须是boolean类型的结果。</p><p>相当于现实生活中的或，比如：买房子交钱时，全款 或者 按揭都可以，如果全款或者按揭，房子都是你的，否则站一边去。</p><table><thead><tr><th style="text-align:center">表达式1</th><th style="text-align:center">表达式2</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">真</td><td style="text-align:center">真</td><td style="text-align:center">真</td></tr><tr><td style="text-align:center">真</td><td style="text-align:center">假</td><td style="text-align:center">真</td></tr><tr><td style="text-align:center">假</td><td style="text-align:center">真</td><td style="text-align:center">真</td></tr><tr><td style="text-align:center">假</td><td style="text-align:center">假</td><td style="text-align:center">假</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">System.out.println(a == <span class="number">1</span> || b == <span class="number">2</span>); <span class="comment">// 左为真 且 右为真 则结果为真</span></span><br><span class="line">System.out.println(a == <span class="number">1</span> || b &gt; <span class="number">100</span>); <span class="comment">// 左为真 但 右为假 则结果也为真</span></span><br><span class="line">System.out.println(a &gt; <span class="number">100</span> || b == <span class="number">2</span>); <span class="comment">// 左为假 但 右为真 则结果也为真</span></span><br><span class="line">System.out.println(a &gt; <span class="number">100</span> || b &gt; <span class="number">100</span>); <span class="comment">// 左为假 且 右为假 则结果为假</span></span><br></pre></td></tr></table></figure><h2 id="3、逻辑非">3、逻辑非<code>!</code></h2><p>语法规则：<code>! 表达式</code></p><p>真变假，假变真。</p><table><thead><tr><th style="text-align:center">表达式</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">真</td><td style="text-align:center">假</td></tr><tr><td style="text-align:center">假</td><td style="text-align:center">真</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">System.out.println(!(a == <span class="number">1</span>)); <span class="comment">// a == 1 为true，取个非就是false</span></span><br><span class="line">System.out.println(!(a != <span class="number">1</span>)); <span class="comment">// a != 1 为false，取个非就是true</span></span><br></pre></td></tr></table></figure><h2 id="4、短路求值">4、短路求值</h2><p><code>&amp;&amp;</code> 和<code> ||</code> 遵守短路求值的规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">10</span> &gt; <span class="number">20</span> &amp;&amp; <span class="number">10</span> / <span class="number">0</span> == <span class="number">0</span>); <span class="comment">// 打印 false</span></span><br><span class="line">System.out.println(<span class="number">10</span> &lt; <span class="number">20</span> || <span class="number">10</span> / <span class="number">0</span> == <span class="number">0</span>); <span class="comment">// 打印 true</span></span><br></pre></td></tr></table></figure><p>我们都知道, 计算 <code>10 / 0 </code>会导致程序抛出异常. 但是上面的代码却能正常运行, 说明 <code>10 / 0 </code>并没有真正被求值</p><p>注意:</p><ul><li><p>对于 <code>&amp;&amp;</code> , 如果<strong>左侧表达式值为</strong> <strong>false,</strong> <strong>则表达式结果一定是</strong> <strong>false,</strong> <strong>无需计算右侧表达式</strong></p></li><li><p>对于 <code>||</code>, 如果<strong>左侧表达式值为</strong> <strong>true,</strong> <strong>则表达式结果一定是</strong> <strong>true,</strong> <strong>无需计算右侧表达式</strong></p></li><li><p><code>&amp;</code> 和 <code>|</code> 如果表达式结果为 boolean 时, 也表示逻辑运算. 但与 <code>&amp;&amp;</code> <code>||</code> 相比, 它们不支持短路求值</p></li></ul><h1>六、位运算符</h1><p>Java 中数据存储的最小单位是字节，而数据操作的最小单位是比特位，字节是最小的存储单位，每个字节是由8个二进制比特位组成的，多个字节组合在一起可以表示各种不同的数据。</p><p>位运算符主要有四个: <code>&amp;</code> <code>|</code> <code>~</code> <code>^</code> ，除<code> ~</code> 是一元运算符外，其余都是二元运算符。</p><p>位操作表示 <strong>按二进制位运算</strong>. 计算机中都是使用二进制来表示数据的(0或1构成的序列), 按位运算就是在按照二进制位的每一位依次进行计算。</p><h2 id="1、按位与">1、按位与<code>&amp;</code></h2><p>位与运算符（&amp;）：将两个数的二进制表示的每一位进行逻辑与操作，只有当两个位都为1时，结果才为1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">System.out.println(a &amp; b);</span><br></pre></td></tr></table></figure><p>进行按位运算, 需要先把 10 和 20 转成二进制, 分别为 1010 和 10100</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305062112205.png" alt="image-20230506211246126"></p><h2 id="2、按位或">2、按位或<code>|</code></h2><p>位或运算符（|）：将两个数的二进制表示的每一位进行逻辑或操作，只有当两个位都为0时，结果才为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">System.out.println(a | b);</span><br></pre></td></tr></table></figure><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/202305062113642.png" alt="image-20230506211334589"></p><p><strong>注意</strong>: 当 <code>&amp;</code> 和 <code>|</code> 的操作数为整数(int, short, long, byte) 的时候, 表示按位运算, 当操作数为 boolean 的时候, 表示逻辑运算</p><h2 id="3、按位取反">3、按位取反<code>~</code></h2><p>取反运算符（~）：将一个数的二进制表示的每一位取反，即0变为1，1变为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0xf</span>;</span><br><span class="line">System.out.printf(<span class="string">&quot;%x\n&quot;</span>, ~a)</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li><p><code>0x</code> 前缀的数字为 十六进制 数字，十六进制可以看成是二进制的简化表示方式. 一个十六进制数字对应 4个二进制位</p></li><li><p><code>0xf</code> 表示 10 进制的 15, 也就是二进制的 1111</p></li><li><p><code>printf</code> 能够格式化输出内容, %x 表示按照十六进制输出</p></li><li><p><code>\n</code> 表示换行符</p></li></ul><h2 id="4、按位异或">4、按位异或<code>^</code></h2><p>位异或运算符（^）：将两个数的二进制表示的每一位进行逻辑异或操作，只有当两个位不同时，结果才为1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0x1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0x2</span>;</span><br><span class="line">System.out.printf(<span class="string">&quot;%x\n&quot;</span>, a ^ b);</span><br></pre></td></tr></table></figure><p>注意：如果两个数相同，则异或的结果为0</p><h1>七、移位运算符</h1><p>移位运算符有三个: <code>&lt;&lt;</code> <code> &gt;&gt;</code> <code>&gt;&gt;&gt;</code> ，都是二元运算符，且都是按照二进制比特位来运算</p><h2 id="1、左移">1、左移<code>&lt;&lt;</code></h2><p>左移运算符（&lt;&lt;）：将一个数的二进制表示向左移动指定的位数，左移后右边补0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0x10</span>;</span><br><span class="line">System.out.printf(<span class="string">&quot;%x\n&quot;</span>, a &lt;&lt; <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 运行结果(注意, 是按十六进制打印的)</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><p>注意：向左移位时，丢弃的是符号位，因此正数左移可能会编程负数</p><h2 id="2、右移">2、右移<code>&gt;&gt;</code></h2><p>右移运算符（&gt;&gt;）：将一个数的二进制表示向右移动指定的位数，右移后左边补符号位，即正数补0，负数补1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0x10</span>;</span><br><span class="line">System.out.printf(<span class="string">&quot;%x\n&quot;</span>, a &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 运行结果(注意, 是按十六进制打印的)</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0xffff0000</span>;</span><br><span class="line">System.out.printf(<span class="string">&quot;%x\n&quot;</span>, b &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 运行结果(注意, 是按十六进制打印的)</span></span><br><span class="line">ffff8000</span><br></pre></td></tr></table></figure><h2 id="3、无符号右移">3、无符号右移 <code>&gt;&gt;&gt;</code></h2><p>无符号右移运算符（&gt;&gt;&gt;）：将一个数的二进制表示向右移动指定的位数，右移后左边补0，不考虑符号位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0xffffffff</span>;</span><br><span class="line">System.out.printf(<span class="string">&quot;%x\n&quot;</span>, a &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 运行结果(注意, 是按十六进制打印的)</span></span><br><span class="line">7fffffff</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>左移 1 位, 相当于原数字 * 2. 左移 N 位, 相当于原数字 * 2 的N次方</p></li><li><p>右移 1 位, 相当于原数字 / 2. 右移 N 位, 相当于原数字 / 2 的N次方</p></li><li><p>由于计算机计算移位效率高于计算乘除, 当某个代码正好乘除 2 的N次方的时候可以用移位运算代替</p></li><li><p>移动负数位或者移位位数过大都没有意义</p></li></ul><h1>八、条件运算符</h1><p>条件运算符只有一个:</p><p><code>表达式1 ? 表达式2 : 表达式3</code></p><p>当 表达式1 的值为 true 时, 整个表达式的值为 表达式2 的值，当 表达式1 的值为 false 时, 整个表达式的值为 表达式3 的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求两个整数的最大值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a &gt; b ? a : b;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>表达式2和表达式3的结果要是同类型的，除非能发生类型隐式类型转换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a &gt; b? <span class="number">1</span> : <span class="number">2.0</span>;</span><br></pre></td></tr></table></figure><ul><li>表达式不能单独存在，其产生的结果必须要被使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">a &gt; b? a : b; </span><br><span class="line"><span class="comment">// 报错：Error:(15, 14) java: 不是语句</span></span><br></pre></td></tr></table></figure><h1>九、运算符的优先级</h1><p>在一条表达式中，各个运算符可以混合起来进行运算，但是运算符的优先级不同。</p><p>比如：<code>*</code> 和 <code>/</code> 的优先级要高于 <code>+</code>和 <code>-</code> ，有些情况下稍不注意，可能就会造成很大的麻烦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求a和b的平均值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + (b - a) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">System.out.println(c);</span><br></pre></td></tr></table></figure><p>上述表达式中，由于 <code>+</code> 的优先级要高于 <code>&gt;&gt;</code> , 因此a先和b-a的结果做加法，整体为20，最后再进行右移，因此结果为10。</p><p>注意：运算符之间是有<strong>优先级</strong>的，具体的规则我们<strong>不必记忆</strong>，在可能存在歧义的代码中加上括号即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求a和b的平均值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + ((b - a) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">System.out.println(c);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">JavaSE：Java的各种常见运算符</summary>
    
    
    
    <category term="笔记" scheme="https://www.zxhy.club/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://www.zxhy.club/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习之旅：数据类型与变量</title>
    <link href="https://www.zxhy.club/posts/java02.html"/>
    <id>https://www.zxhy.club/posts/java02.html</id>
    <published>2023-05-05T02:20:23.000Z</published>
    <updated>2023-05-05T02:51:03.959Z</updated>
    
    <content type="html"><![CDATA[<h1>一、前言</h1><p>在Java这门“啰嗦”的编程语言中,我们必须弄清楚每种数据类型的性质和用途,才能让程序“说人话”。要成为Java高手，就必须与各种数据类型打成一片。</p><p>本文则将带你认识Java中常见的两位“角色”—数据类型与变量。</p><h1>二、数据类型</h1><p>在Java中数据类型主要分为两类：<strong>基本数据类型</strong>和<strong>引用数据类型</strong>。</p><p>基本数据类型有四类八种：</p><p><strong>四类：整型、浮点型、字符型以及布尔型</strong></p><p><strong>八种：字节型、短整型、整型、长整型、单精度浮点型、双精度浮点型、字符型、布尔型</strong></p><table><thead><tr><th style="text-align:center"><strong>数据类型</strong></th><th style="text-align:center"><strong>关键字</strong></th><th style="text-align:center"><strong>内存占用（字节）</strong></th><th style="text-align:center"><strong>范围</strong></th></tr></thead><tbody><tr><td style="text-align:center">字节型</td><td style="text-align:center"><code>byte</code></td><td style="text-align:center">1</td><td style="text-align:center">-128 ~ 127</td></tr><tr><td style="text-align:center">短整型</td><td style="text-align:center"><code>short</code></td><td style="text-align:center">2</td><td style="text-align:center">-32768 ~ 32767</td></tr><tr><td style="text-align:center">整型</td><td style="text-align:center"><code>int</code></td><td style="text-align:center">4</td><td style="text-align:center">-2^31~2^31-1</td></tr><tr><td style="text-align:center">长整型</td><td style="text-align:center"><code>long</code></td><td style="text-align:center">8</td><td style="text-align:center">-2^63~2^63-1</td></tr><tr><td style="text-align:center">单精度浮点型</td><td style="text-align:center"><code>float</code></td><td style="text-align:center">4</td><td style="text-align:center">有范围，一般不关注</td></tr><tr><td style="text-align:center">双精度浮点型</td><td style="text-align:center"><code>double</code></td><td style="text-align:center">8</td><td style="text-align:center">有范围，一般不关注</td></tr><tr><td style="text-align:center">字符型</td><td style="text-align:center"><code>char</code></td><td style="text-align:center">2</td><td style="text-align:center">0 ~ 65535</td></tr><tr><td style="text-align:center">布尔型</td><td style="text-align:center"><code>boolean</code></td><td style="text-align:center">没有规定</td><td style="text-align:center">true 和 false</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li><p>不论是在16位系统还是32位系统，<code>int</code>都占用4个字节，<code>long</code>都占8个字节</p></li><li><p>整形和浮点型都是带有符号的</p></li><li><p>整型默认为<code>int</code>型，浮点型默认为<code>double</code></p></li></ul><p><strong>什么是字节：</strong></p><p>上面提到了每个数据类型的内存占用的单位是字节，那么什么是字节呢？</p><blockquote><p>字节是计算机中表示空间大小的基本单位。</p><p>根据IEEE计算机学会的定义，字节(byte)是一组连续的比特(bit)，其大小是8个比特。</p><p>一个比特可以放一个二进制数字，而一个字节由8个二进制位数组成。所以它的二进制范围是00000000到11111111，对应的十进制数是0到255。</p></blockquote><h1>三、变量</h1><h2 id="1、变量的定义">1、变量的定义</h2><p>变量用于在程序运行时表示数据,并能随之变化。变量名用于标识变量，数据类型定义变量的值的类型，值是变量包含的数据,存储单元用来保存变量的值。</p><p>简而言之：<strong>对于经常改变的内容，在Java程序中，称为变量</strong>。<strong>而数据类型就是用来定义不同种类变量的。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//定义整形变量a，a是变量名也称为标识符，该变量中放置的值为10</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">10</span>, a2 = <span class="number">20</span>, a3 = <span class="number">30</span>;<span class="comment">// 注意：在一行可以定义多个相同类型的变量</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3.14</span>;<span class="comment">//定义双精度浮点型变量d，该变量中放置的值为3.14</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;<span class="comment">//定义字符型变量c，该变量中放置的为字符&#x27;A&#x27;</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//定义一个布尔类型变量，该变量的值为true</span></span><br></pre></td></tr></table></figure><h2 id="2、整型变量">2、整型变量</h2><h3 id="Ⅰ、整型变量">Ⅰ、整型变量</h3><p><strong>方式一：在定义时给出初始值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure><p><strong>方式二：在定义时没有给初始值，但使用前必须设置初值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b;</span><br><span class="line">b = <span class="number">10</span>;</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure><p>我在定义时就不赋初始值，会发生什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c;</span><br><span class="line">System.out.println(c);</span><br><span class="line">c = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>会报错！！！！！</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/20230504180831.png" alt=""></p><p>int型变量所能表示的范围？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.MIN_VALUE);<span class="comment">//int类型的最小值</span></span><br><span class="line">System.out.println(Integer.MAX_VALUE);<span class="comment">//int类型的最大值</span></span><br></pre></td></tr></table></figure><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/20230504180736.png" alt=""></p><p>注意事项：</p><ul><li><code>int</code>不论在何种系统下都是4个字节</li><li>推荐使用方式一定义，如果没有合适的初始值，可以设置为0</li><li>在给变量设置初始值时，值不能超过int的表示范围，否则会导致溢出</li><li>变量在使用之前必须要赋初值，否则编译报错</li><li><code>int</code>的包装类型为<code>Integer</code></li></ul><h3 id="Ⅱ、长整型变量">Ⅱ、长整型变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// long定义的长整型变量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10L</span>; <span class="comment">// 为了区分int和long类型，一般建议：long类型变量的初始值之后加L或者l</span></span><br><span class="line"><span class="type">long</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">10l</span>; <span class="comment">// 一般更加以加大写L，因为小写l与1不好区分</span></span><br></pre></td></tr></table></figure><p><code>long</code>型变量所能表示的范围：这个数据范围远超过 int 的表示范围，足够绝大部分的工程场景使用。</p><p>那么long类型的变量表示的范围大概是多少呢？同样的，可以写一个程序测一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Long.MIN_VALUE);<span class="comment">//int类型的最小值</span></span><br><span class="line">System.out.println(Long.MAX_VALUE);<span class="comment">//int类型的最大值</span></span><br></pre></td></tr></table></figure><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/20230504181433.png" alt=""></p><p>注意事项：</p><ul><li><p>长整型变量的初始值后加L或者l，推荐加L</p></li><li><p>长整型不论在那个系统下都占8个字节</p></li><li><p>长整型的表示范围为：-2^63~2^63-1</p></li><li><p><code>long</code>的包装类型为<code>Long</code></p></li></ul><h3 id="Ⅲ、短整型变量">Ⅲ、短整型变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// short型变量所能表示的范围：</span></span><br><span class="line">System.out.println(Short.MIN_VALUE);</span><br><span class="line">System.out.println(Short.MAX_VALUE);</span><br></pre></td></tr></table></figure><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/20230504181739.png" alt=""></p><p>注意事项：</p><ul><li><p><code>short</code>在任何系统下都占2个字节</p></li><li><p><code>short</code>的表示范围为：-32768 ~ 32767</p></li><li><p>使用时注意不要超过范围(一般使用比较少)</p></li><li><p><code>short</code>的包装类型为<code>Short</code></p></li></ul><h2 id="3、字节型变量">3、字节型变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// byte型变量所能表示的范围：</span></span><br><span class="line">System.out.println(Byte.MIN_VALUE);</span><br><span class="line">System.out.println(Byte.MAX_VALUE);</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li><p><code>byte</code>在任何系统下都占1个字节</p></li><li><p><code>byte</code>的范围是：-128 ~ 127</p></li><li><p>字节的包装类型为<code>Byte</code></p></li></ul><h2 id="4、浮点型变量">4、浮点型变量</h2><h3 id="Ⅰ、双精度浮点型">Ⅰ、双精度浮点型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line">system.out.println(d);</span><br></pre></td></tr></table></figure><p>为了更好的区分浮点型和整型的区别，我们可以看一下下面的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">System.out.println(a / b);</span><br></pre></td></tr></table></figure><p>上面的代码输出的是0.5 吗？</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/20230505094228.png" alt=""></p><p>结果居然是0，为什么呢？</p><p>**这是因为在 Java 中, <code>int</code> 除以<code> int</code> 的值仍然是 <code>int</code>(会直接舍弃小数部分)。**如果想得到 0.5, 需要使用 <code>double</code> 类型计算.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2.0</span>;</span><br><span class="line">System.out.println(a / b); <span class="comment">// 输出0.5</span></span><br></pre></td></tr></table></figure><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/20230505094435.png" alt=""></p><p>我们可以再看一个神奇的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1.1</span>;</span><br><span class="line">System.out.println(num * num);</span><br></pre></td></tr></table></figure><p>上面的代码输出的是1.21吗？</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/20230505094639.png" alt=""></p><p><code>double</code> 类型的内存布局遵守 IEEE 754 标准(和C语言一样), 尝试使用有限的内存空间表示可能无限的小数, 势必会存在一定的精度误差，因此浮点数是个近似值，并不是精确值。</p><p>注意事项：</p><ul><li><p><code>double</code>在任何系统下都占8个字节</p></li><li><p>浮点数与整数在内存中的存储方式不同，不能单纯使用 的形式来计算</p></li><li><p><code>double</code>的包装类型为<code>Double</code></p></li><li><p><code>double</code> 类型的内存布局遵守 IEEE 754 标准(和C语言一样), 尝试使用有限的内存空间表示可能无限的小数, 势必会存在一定的精度误差，因此浮点数是个近似值，并不是精确值。</p></li></ul><h3 id="Ⅱ、单精度浮点型">Ⅱ、单精度浮点型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1.0f</span>; <span class="comment">// 写作 1.0F 也可以</span></span><br><span class="line">System.out.println(num);</span><br></pre></td></tr></table></figure><p><code>float</code> 类型在 Java 中占四个字节, 同样遵守 IEEE 754 标准. 由于表示的数据精度范围较小, 一般在工程上用到浮点数都优先考虑 <code>double</code>, 不太推荐使用 <code>float</code>,<code>float</code>的包装类型为<code>Float</code>。</p><h2 id="5、字符型变量">5、字符型变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 大写字母</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>; <span class="comment">// 数字字符</span></span><br><span class="line">System.out.println(c1);</span><br><span class="line">System.out.println(c2);</span><br><span class="line"><span class="comment">// 注意：java中的字符可以存放整形</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="string">&#x27;帅&#x27;</span>;</span><br><span class="line">System.out.println(c3);</span><br></pre></td></tr></table></figure><p>注意事项:</p><ul><li><p>Java 中使用 单引号 + 单个字母 的形式表示字符字面值.</p></li><li><p>计算机中的字符本质上是一个整数. 在 C 语言中使用 ASCII 表示字符, 而 Java 中使用 Unicode 表示字符. 因此一个字符占用两个字节, 表示的字符种类更多, 包括中文.</p></li><li><p><code>char</code>的包装类型为<code>Character</code></p></li></ul><h2 id="6、布尔型变量">6、布尔型变量</h2><p>布尔类型常用来表示真假。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">System.out.println(b);</span><br><span class="line">b = <span class="literal">false</span>;</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li><p><code>boolean</code> 类型的变量只有两种取值, <code>true</code> 表示真, <code>false</code> 表示假.</p></li><li><p>Java 的 <code>boolean</code> 类型和 int 不能相互转换, <strong>不存在</strong> 1 表示 true, 0 表示 false 这样的用法.</p></li><li><p>Java虚拟机规范中，并没有明确规定<code>boolean</code>占几个字节，也没有专门用来处理<code>boolean</code>的字节码指令，在Oracle公司的虚拟机实现中，<code>boolean</code>占1个字节。</p></li><li><p><code>boolean</code>的包装类型为<code>Boolean</code>。</p></li></ul><p><strong>包装类是什么？</strong></p><blockquote><p>包装类指的是，基本数据类型对应的类类型。因为基本数据类型无法进行对象化处理，所以就引入了包装类。</p><p>8种基本数据byte、short、int、long、 float、double、char、boolean。除了int对应的是Integer，char对应的是Character。其余都是首字母大写即可。</p></blockquote><h1>四、类型转换</h1><p>Java 作为一个强类型编程语言, 当不同类型之间的变量相互赋值的时候, 会有教严格的校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100L</span>;</span><br><span class="line">b = a; <span class="comment">// 可以通过编译</span></span><br><span class="line">a = b; <span class="comment">// 编译失败</span></span><br></pre></td></tr></table></figure><p>在Java中，当参与运算数据类型不一致时，就会进行类型转换。Java中类型转换主要分为两类：自动类型转换(隐式) 和 强制类型转换(显式)。</p><h2 id="1、自动类型转换-隐式">1、自动类型转换(隐式)</h2><p>自动类型转换即：<strong>代码不需要经过任何处理，在代码编译时，编译器会自动进行处理</strong>。</p><p>特点：<strong>数据范围小的转为数据范围大的时会自动进行。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">System.Out.println(<span class="number">1024</span>); <span class="comment">// 整型默认情况下是int</span></span><br><span class="line">System.Out.println(<span class="number">3.14</span>); <span class="comment">// 浮点型默认情况下是double</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10L</span>;</span><br><span class="line">b = a; <span class="comment">// a和b都是整形，a的范围小，b的范围大，当将a赋值给b时，编译器会自动将a提升为long类型，然后赋值</span></span><br><span class="line">a = b; <span class="comment">// 编译报错，long的范围比int范围大，会有数据丢失，不安全</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">3.14F</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">5.12</span>;</span><br><span class="line">d = f; <span class="comment">// 编译器会将f转换为double，然后进行赋值</span></span><br><span class="line">f = d; <span class="comment">// double表示数据范围大，直接将float交给double会有数据丢失，不安全</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 编译通过，100没有超过byte的范围，编译器隐式将100转换为byte</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">257</span>; <span class="comment">// 编译失败，257超过了byte的数据范围，有数据丢失</span></span><br></pre></td></tr></table></figure><h2 id="2、强制类型转换（显式">2、强制类型转换（显式)</h2><p>强制类型转换：<strong>当进行操作时，代码需要经过一定的格式处理，不能自动完成。</strong></p><p>特点：<strong>数据范围大的到数据范围小的。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100L</span>;</span><br><span class="line">b = a; <span class="comment">// int--&gt;long，数据范围由小到大，隐式转换</span></span><br><span class="line">a = (<span class="type">int</span>)b; <span class="comment">// long--&gt;int, 数据范围由大到小，需要强转，否则编译失败</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">3.14F</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">5.12</span>;</span><br><span class="line">d = f; <span class="comment">// float--&gt;double，数据范围由小到大，隐式转换</span></span><br><span class="line">f = (<span class="type">float</span>)d; <span class="comment">// double--&gt;float, 数据范围由大到小，需要强转，否则编译失败</span></span><br><span class="line">a = d; <span class="comment">// 报错，类型不兼容</span></span><br><span class="line">a = (<span class="type">int</span>)d; <span class="comment">// int没有double表示的数据范围大，需要强转，小数点之后全部丢弃</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 100默认为int，没有超过byte范围，隐式转换</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> (<span class="type">byte</span>)<span class="number">257</span>; <span class="comment">// 257默认为int，超过byte范围，需要显示转换，否则报错</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">a = flag; <span class="comment">// 编译失败：类型不兼容</span></span><br><span class="line">flag = a; <span class="comment">// 编译失败：类型不兼容</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li><p>不同数字类型的变量之间赋值, 表示范围更小的类型能隐式转换成范围较大的类型</p></li><li><p>如果需要把范围大的类型赋值给范围小的, 需要强制类型转换, 但是<strong>可能精度丢失</strong></p></li><li><p>将一个字面值常量进行赋值的时候, Java 会自动针对数字范围进行检查</p></li><li><p>强制类型转换不一定能成功，不相干的类型不能互相转换</p></li></ul><h2 id="3、-类型提升">3、 类型提升</h2><p>不同类型的数据之间相互运算时，数据类型小的会被提升到数据类型大的。</p><h3 id="Ⅰ、int提升为long">Ⅰ、int提升为long</h3><p><code>int</code>与<code>long</code>之间：<code>int</code>会被提升为<code>long</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b; <span class="comment">// 编译出错: a + b==》int + long--&gt; long + long 赋值给int时会丢失数据</span></span><br><span class="line"><span class="type">long</span> <span class="variable">d</span> <span class="operator">=</span> a + b; <span class="comment">// 编译成功：a + b==&gt;int + long---&gt;long + long 赋值给long</span></span><br></pre></td></tr></table></figure><h3 id="Ⅱ、byte与byte的运算">Ⅱ、byte与byte的运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">System.out.println(c);</span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line">Test.java:<span class="number">5</span>: 错误: 不兼容的类型: 从<span class="type">int</span>转换到<span class="type">byte</span>可能会有损失</span><br><span class="line"><span class="type">byte</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">   ^</span><br></pre></td></tr></table></figure><p><strong>结论</strong>: byte 和 byte 都是相同类型, 但是出现编译报错. 原因是, 虽然 a 和 b 都是 byte, 但是计算 a + b 会先将 a和 b 都提升成 int, 再进行计算, 得到的结果也是 int, 这是赋给 c, 就会出现上述错误。由于计算机的 CPU 通常是按照 4 个字节为单位从内存中读写数据. 为了硬件上实现方便, 诸如 byte 和 short这种低于 4 个字节的类型, 会先提升成 int, 再参与计算。</p><p>所以，正确的写法应该是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">byte</span>)(a + b);</span><br><span class="line">System.out.println(c);</span><br></pre></td></tr></table></figure><h3 id="Ⅲ、小结">Ⅲ、小结</h3><ul><li><p>不同类型的数据混合运算, 范围小的会提升成范围大的.</p></li><li><p>对于<code>short</code>,<code>byte</code> 这种比 4 个字节小的类型, 会先提升成 4 个字节的 <code>int</code> , 再运算</p></li></ul><h1>五、字符串类型</h1><p><code>String</code>是Java中一种引用数据类型，用于表示文本字符串，这里简单的说一下基础用法。</p><p>在Java中使用<code>String</code>类定义字符串类型，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot; world&quot;</span>;</span><br><span class="line">System.out.println(s1);</span><br><span class="line">System.out.println(s2);</span><br><span class="line">System.out.println(s1+s2); <span class="comment">// s1+s2表示：将s1和s2进行拼接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在有些情况下，需要将字符串和整形数字之间进行转换。</p><h2 id="1、int转String">1、int转String</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> num + <span class="string">&quot;&quot;</span>; </span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> String.valueOf(num);</span><br></pre></td></tr></table></figure><h2 id="2、String转int">2、String转int</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;100&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">JavaSE：Java的数据类型与变量</summary>
    
    
    
    <category term="笔记" scheme="https://www.zxhy.club/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://www.zxhy.club/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习之旅：初识Java</title>
    <link href="https://www.zxhy.club/posts/java01.html"/>
    <id>https://www.zxhy.club/posts/java01.html</id>
    <published>2023-04-26T18:20:23.000Z</published>
    <updated>2023-04-26T18:23:07.358Z</updated>
    
    <content type="html"><![CDATA[<h1>一、前言</h1><p><strong>Java是一种非常优秀的程序设计语言</strong>，它具有令人赏心悦目的语法和易于理解的语义。</p><p>本文将通过一个简单的Java程序，介绍Java的一些基础内容。</p><h1>二、Java基本结构</h1><h2 id="1、简单的Java程序">1、简单的Java程序</h2><p>从最简单的一个Java程序开始逐渐了解Java语言。</p><p>以下是一段Java最简单的代码，效果是输出：Hello World ! 我们将通过分析这段最简单的代码，慢慢了解Java语言。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123; <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; <span class="comment">// (2)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);<span class="comment">// (3)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）这是一个类的开始声明，表示这个类名为<code>Test</code>，其中<code>public</code>是访问修饰符，表示这个类是公共的，可以被其他类访问。</p><p>（2）这是Java程序运行的入口点，其中<code>public</code>是访问修饰符，表示这个方法是公共的，可以被其他类访问。<code>static</code>是静态修饰符，表示这个方法属于<code>Test</code>类的，而非<code>Test</code>类的实例，可以通过类名直接调用。<code>void</code>表示这个方法没有返回值，<code>main</code>是这个方法的名称。<code>String[] args</code>是命令行参数部分，即在命令行中输入的参数会以字符串数组的方式传递给<code>main</code>方法。</p><p>（3）<code>System</code>：这是 <code>Java </code>编程语言提供的一个类。这个类包含了对<code>Java</code>应用程序环境的访问，以及标准输入、输出和错误输出流等功能。<code>out</code>表示 <code>System</code> 类中的标准输出流。可以使用<code> System.out</code> 来访问这个输出流对象。<code>println</code>表示将输出的内容打印到输出流上，并且在结尾处自动添加一个换行符。这是 <code>print 和 ln </code>两个方法的组合。</p><h2 id="2、运行Java程序">2、运行Java程序</h2><p><code>Java</code>是一门半编译型、半解释型语言。先通过<code>javac</code>编译程序把源文件进行编译，编译后生成的<code>.class</code>文件是由字节码组成的平台无关、面向<code>JVM</code>的文件。最后启动<code>java</code>虚拟机来运行<code>.class</code>文件，此时<code>JVM</code>会将字节码转换成平台能够理解的形式来运行。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/20230427011754.png" alt=""></p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/20230427015531.png" alt=""></p><p>注意：在运行<code>Java</code>程序前，必须先安装好<code>JDK</code>(<code>Java Development Kit</code>即<code>Java</code>开发工具包)，<code>JDK</code>里面就包含了<code>javac</code>和<code>java</code>工具，<code>Java</code>程序最终是在<code>JVM</code>(<code>Java</code>虚拟机)中运行的。</p><blockquote><p>【面试题】<strong><code>JDK</code>、<code>JRE</code>、<code>JVM</code>之间的关系？</strong></p><ul><li><p><code>JDK(Java Development Kit):Java</code>开发工具包，提供给Java程序员使用，包含了<code>JRE</code>，同时还包含了编译器<code>javac</code>与自带的调试工具<code>Jconsole</code>、<code>jstack</code>等。</p></li><li><p><code>JRE(Java Runtime Environment):Java</code>运行时环境，包含了<code>JVM</code>，<code>Java</code>基础类库。是使用<code>Java</code>语言编写程序运行的所需环境。</p></li><li><p><code>JVM</code>：<code>Java</code>虚拟机，运行<code>Java</code>代码</p></li><li><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/20230427013628.png" alt=""></p></li></ul></blockquote><h1>三、Java注释标准</h1><p>注释是为了让代码更容易被读懂而附加的描述信息. 不参与编译运行, 但是却非常重要<strong>时刻牢记</strong> ！</p><p>代码写出来是为了给人看的, 更是为了给三个月后的你自己看的.</p><h2 id="1、注释规则">1、注释规则</h2><p>Java中的注释主要分为以下三种：</p><ul><li>单行注释：<code>//注释内容</code></li><li>多行注释：<code>/* 注释内容*/</code></li><li>文档注释：<code> /** 文档注释 */</code>（常见于方法和类之上描述方法和类的作用)，可以被<code>javadoc</code>工具解析，生成一套以网页文件形式体现的程序说明文档。</li></ul><p>注意：</p><ul><li><p>多行注释不能嵌套使用。</p></li><li><p>不论是单行还是多行注释，都不参与编译，即编译之后生成的<code>.class</code>文件中不包含注释信息。</p></li></ul><h2 id="2、注释规范">2、注释规范</h2><ul><li><p>内容准确: 注释内容要和代码一致, 匹配, 并在代码修改时及时更新。</p></li><li><p>篇幅合理: 注释既不应该太精简, 也不应该长篇大论。</p></li><li><p>使用中文: 一般中国公司都要求使用中文写注释, 外企另当别论。</p></li><li><p>积极向上: 注释中不要包含负能量。</p></li></ul><h1>四、标识符与关键字</h1><h2 id="1、标识符">1、标识符</h2><p>在上述程序中，<code>Test</code>称为类名，<code>main</code>称为方法名，也可以将其称为标识符，即：<strong>在程序中由用户给类名、方法名或者变量所取的名字</strong>。</p><p>一个大型的工程，是由多名工程师协同开发的，如果每个人都按照自己的方式随意取名。</p><p>比如：person、PERSON、Person、_person，将会使程序非常混乱。如果大家在取名时能够遵守一定的约束(即规范)，那多人写</p><p>出来的代码仿佛一个人写的，能极大的提高程序的可读性。</p><p>【<strong>硬性规则</strong>】</p><ul><li><p><strong>标识符中可以包含：字母、数字以及 下划线和</strong> <strong>$</strong> <strong>符号等等。</strong></p></li><li><p><strong>注意：标识符不能以数字开头，也不能是关键字，且严格区分大小写</strong>。</p></li></ul><p>【<strong>软性建议</strong>】</p><ul><li><p><strong>类名：每个单词的首字母大写(大驼峰)</strong></p></li><li><p><strong>方法名：首字母小写，后面每个单词的首字母大写(小驼峰)</strong></p></li><li><p><strong>变量名：与方法名规则相同</strong></p></li></ul><h2 id="2、关键字">2、关键字</h2><p>通过观察上述程序可以发现，<code>public</code>、<code>class</code>以及<code>static</code>等颜色会发生变化，将这些具有特殊含义的标识符称为关键字。即：<strong>关键字是由Java语言提前定义好的，有特殊含义的标识符，或者保留字</strong>。</p><p><strong>注意：用户不能使用关键字定义标识符。</strong></p><p>以下是<code>Java</code>的关键字：</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/20230427011547.png" alt=""></p>]]></content>
    
    
    <summary type="html">JavaSE：Java的基本结构及标识符</summary>
    
    
    
    <category term="笔记" scheme="https://www.zxhy.club/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://www.zxhy.club/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java环境准备：JDK的安装</title>
    <link href="https://www.zxhy.club/posts/java00.html"/>
    <id>https://www.zxhy.club/posts/java00.html</id>
    <published>2023-04-26T17:15:13.000Z</published>
    <updated>2023-05-07T05:30:04.751Z</updated>
    
    <content type="html"><![CDATA[<h1>1、简介</h1><ul><li>JDK : Java SE Development Kit Java开发工具</li><li>JRE : Java Runtime Environment Java运行环境</li></ul><p>如果要从事Java编程，则需要安装JDK，如果仅仅是运行一款Java程序则JRE就满足要求。</p><blockquote><p>Java的安装包分为两类，一类是JRE其就是一个独立的Java运行环境； 一类是JDK其是Java的开发环境，不过在JDK的发布包中包含了一个独立的JRE，另外需要注意JDK本身就内置有JRE。</p></blockquote><h1>2、安装</h1><p>在Windows下安装<code>JDK</code>的时候一定要考虑安装包的位数，如果是32位操作系统，则准备<code>jdk-xxx-windows-i586.exe</code>,如果是64位操作系统，则准备<code>jdk-xxx-windows-x64.exe</code>。</p><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html">JDK：Oracle官方下载</a>，下文中安装的是64位操作系统下的<code>JDK</code>，32位操作系统下安装方式同理。</p><p>以下安装也是1.8的安装，只是小版本号不一样，其他操作全部一样。</p><p>第一步：执行安装包<code>jdk-8u131-windows-x64.exe</code> ，出现如下图界面，点击下一步。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/20230427024324.png" alt=""></p><ul><li>第二步：安装开发工具和源代码即可；JDK安装包中包含了一个独立的JRE，作为开发机器可以不用安装，因此这里选择此功能将不用（下图二）；不建议更改安装目录，采用默认即可；点击下一步。</li></ul><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/20230427024356.png" alt=""></p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/20230427024413.png" alt=""></p><ul><li>第三步：稍等片刻，安装完成</li></ul><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/20230427024446.png" alt=""></p><h1>3、配置</h1><p>关于JDK的配置，网上流传的方法特别多，有的也特别复杂，完全不可取。配置之前，先弄清楚到底配置什么东西。</p><p>第一：<code>JAVA_HOME</code>环境变量，值为JDK的安装目录，为什么要这么配置能，主要是应为很多开源软件的依赖到这个变量，用于寻找机器上的Java环境，比如：<code>Tomcat</code> , <code>Maven</code></p><p>第二：<code>Path</code>变量值中<strong>追加</strong>Java命令的路径，道理很简单，就是希望能够在命令行中，直接使用JDK中提供的命令，比如：<code>java</code>, <code>javac</code></p><p>在JDK1.6以及之后，安装Java的开发环境，只需要配置上面两个内容即可。</p><ul><li><p>第一步：</p><p>配置<code>JAVA_HOME</code></p></li></ul><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/20230427024538.png" alt=""></p><ul><li><p>第二步：</p><p>配置<code>Path</code>, 需要注意<code>Path</code>路径一般是存在的，只需要追加即可。这里使用<code>%JAVA_HOME%</code>的意思是直接引用上面配置的<code>JAVA_HOME</code>的值，这样的好处在于，如果Java安装目录发生变话，主需要修改<code>JAVA_HOME</code>的值，不用再修改<code>Path</code>变量的值。</p></li></ul><blockquote><p>重要！！部分Windows10的系统在重启之后<code>%JAVA_HOME%\bin</code>配置的失效，这里解决方法是配置全路径即可，比如：<code>C:\Program Files\Java\jdk1.8.0_131\bin</code></p></blockquote><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/20230427024615.png" alt=""></p><blockquote><p>注意：Windows 8 ， 10的Path变量配置要友好一些，直接配置一条记录即可，如果是Windows7的话，需要在Path变量的值中使用<code>;</code>(英文分号)分割，然后追加Java的安装目录下的bin目录路径即可。</p></blockquote><p>第三步：配置CLASSPATH</p><p>变量名： CLASSPATH<br>变量值： .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar<br>注意前面的 . 这个点号不能省略掉</p><h1>4、检验</h1><p>安装完成JDK以及相应的配置之后，需要验证是否安装成功，是否配置正常。</p><p>第一步：打开<code>cmd</code>命令行窗口</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/20230427024708.png" alt=""></p><p>第二步：输出<code>java -version</code>命令，如果输出如下图，表示安装配置成功，否则需要检查安装和配置是否正确。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/20230427024740.png" alt=""></p>]]></content>
    
    
    <summary type="html">Java运行环境准备：JDK的安装与配置</summary>
    
    
    
    <category term="笔记" scheme="https://www.zxhy.club/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://www.zxhy.club/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>旋转数组的最小数字</title>
    <link href="https://www.zxhy.club/posts/jz02.html"/>
    <id>https://www.zxhy.club/posts/jz02.html</id>
    <published>2023-04-15T19:30:23.000Z</published>
    <updated>2023-04-20T19:55:07.011Z</updated>
    
    <content type="html"><![CDATA[<h1>一、题目描述</h1><h2 id="1、题目">1、题目</h2><p><a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?">剑指offer：旋转数组的最小数字</a></p><p>有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/20230323001347.png" alt=""></p><h2 id="2、示例">2、示例</h2><h3 id="示例1">示例1</h3><p>输入：<code>[3,4,5,1,2]</code></p><p>输出：<code>1</code></p><h3 id="示例2">示例2</h3><p>输入：<code>[3,100,200,3]</code></p><p>输出：<code>3</code></p><h1>二、题目分析</h1><h2 id="1、暴力法">1、暴力法</h2><p>旋转数组的原数组是一个非降序数组，也就是说，原数组中的元素是按照从小到大的顺序排列的。当将一个非降序数组旋转后，我们可以把旋转数组分为两部分，一部分是最大的一段非降序子数组，另一部分是最小的一段非降序子数组。旋转数组的最小元素就在这两部分之间。比如，数组[3, 4, 5,1,2] 它的最大的一段非降序子数组是[3,4,5]最小的一段非降序子数组是[1,2] ，而最小元素就是最小的非降序子数组的第一个数。</p><p>所以说，非降序数组在旋转之后有一个特征，就是在遍历的时候，原始数组是非递减的，旋转之后，就有可能出现递减，而引起递减的数字，就是最小值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = numbers.<span class="built_in">size</span>();<span class="comment">//（1）</span></span><br><span class="line">        <span class="type">int</span> min = numbers[<span class="number">0</span>];<span class="comment">//（2）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;n;i++) <span class="comment">//（3）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] &lt; numbers[i<span class="number">-1</span>])<span class="comment">//（4）</span></span><br><span class="line">            &#123;</span><br><span class="line">                min = numbers[i];</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//（5）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（1）获取旋转数组的长度</p><p>（2）让旋转数组中第一个元素为最小值</p><p>（3）从第二个元素开始遍历旋转数组</p><p>（4）如果当前元素比前一个元素小，证明引出现了递减，那么当前元素就是旋转数组的最小元素</p><p>（5）找到了最小元素，跳出循环</p><h2 id="2、二分法">2、二分法</h2><p>我们要知道一件事，暴力查找的过程，本质是排除的过程，但是暴力遍历一次只能排除一个，效率过低。既然是查找，我们就可以用二分查找法来缩减时间复杂度。</p><p>前面分析过，旋转数组的最小值位于非降序子数组和旋转子数组的交界处。所以，我们可以使用二分查找来查找旋转子数组的第一个元素，也就是最小值。旋转数组的最小值一定在数组的旋转点左侧或者就是旋转点。因此，在查找过程中，我们需要缩小查找区间，尽可能保留可能包含最小值的区间使用<code>left</code>和<code>right</code>指针确定查找区间，缩小区间的方式是根据<code>mid</code>的值与<code>right</code>的值的大小关系进行判断。如果<code>numbers[mid]&gt;numbers[right]</code>，说明最小值在<code>mid</code>的右侧，将<code>left</code>指针移动到<code>mid+1</code>的位置；如果<code>numbers[mid]&lt;numbers[right]</code>，说明最小值在<code>mid</code>的左侧或者就是<code>mid</code>，将<code>right</code>指针移动到<code>mid</code>的位置；如果<code>numbers[mid] == numbers[right]</code>，说明可能是一个旋转点，也可能不是，将<code>right</code>指针移动一位。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/20230323_182314.gif" alt="图片来自：Krahets"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> n = numbers.<span class="built_in">size</span>();</span><br><span class="line">       <span class="type">int</span> left = <span class="number">0</span>,right = n<span class="number">-1</span>;</span><br><span class="line">       <span class="comment">//二分查找</span></span><br><span class="line">       <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="type">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(numbers[mid]&gt;numbers[right])</span><br><span class="line">                 left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid]&lt;numbers[right])</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span>   </span><br><span class="line">                right --;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> numbers[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>三、代码汇总</h1><h2 id="1、暴力法-2">1、暴力法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = numbers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> min = numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;n;i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] &lt; numbers[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                min = numbers[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2、二分法-2">2、二分法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> n = numbers.<span class="built_in">size</span>();</span><br><span class="line">       <span class="type">int</span> left = <span class="number">0</span>,right = n<span class="number">-1</span>;</span><br><span class="line">       <span class="comment">//二分查找</span></span><br><span class="line">       <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="type">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(numbers[mid]&gt;numbers[right])</span><br><span class="line">                 left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid]&lt;numbers[right])</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span>   </span><br><span class="line">                right --;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> numbers[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">剑指offer：旋转数组的最小数字</summary>
    
    
    
    <category term="刷题" scheme="https://www.zxhy.club/categories/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="剑指offer" scheme="https://www.zxhy.club/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="https://www.zxhy.club/posts/jz01.html"/>
    <id>https://www.zxhy.club/posts/jz01.html</id>
    <published>2023-04-14T19:30:23.000Z</published>
    <updated>2023-04-20T19:55:00.708Z</updated>
    
    <content type="html"><![CDATA[<h1>一、题目描述</h1><h2 id="1、题目">1、题目</h2><p><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?">剑指offer：二维数组中的查找</a><br>在一个二维数组<code>array</code>中，每个一维数组的长度相同，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="2、示例">2、示例</h2><h3 id="示例Ⅰ">示例Ⅰ</h3><p>输入：<code>7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</code><br>返回值：<code>true</code><br>说明：存在<code>7</code>，返回<code>true  </code></p><h3 id="示例Ⅱ">示例Ⅱ</h3><p>输入：<code>3,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</code><br>返回值：<code>false</code><br>说明：不存在<code>3</code>，返回<code>false </code></p><h1>二、题目分析</h1><h2 id="1、暴力法">1、暴力法</h2><p>看见这道题的第一想法就是暴力法，通过两个循环，从二维数组的起始元素开始逐个遍历，如果当前元素等于目标值，则返回<code>true</code>，如果当前元素小于目标值，则继续遍历，如果遍历完所有元素还没有找到，就返回<code>false</code>。<br>我们使用C++语言来实现此方法，在C++中，我们可以用<code>vector</code>嵌套<code>vector</code>的方式来表示二维数组。<br><code>empty()</code>判断数组是否为空<br><code>size()</code>返回数组中元素的数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> target, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; array)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.<span class="built_in">empty</span>())  <span class="comment">//（1）</span></span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> rows = array.<span class="built_in">size</span>(); <span class="comment">//（2）</span></span><br><span class="line">        <span class="type">int</span> cols = array[<span class="number">0</span>].<span class="built_in">size</span>(); <span class="comment">//（3）</span></span><br><span class="line">        <span class="comment">/*开始暴力遍历*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;rows;i++)  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;j&lt;cols;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(array[i][j]==target) </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（1）如果是空数组的话，直接返回<code>false</code><br>（2）获取数组的行数<br>（3）获取数组的列数</p><p>暴力法的时间复杂度为O(mn)，其中m和n分别是数组的行数和列数。</p><h2 id="2、二分法">2、二分法</h2><p>暴力法虽然能解决这个问题，但是时间复杂度比较高。<br>但是仔细想一下，暴力查找的过程，本质就是排除的过程，如果双循环暴力查找，本质是一次排除一个，效率过低，既然是查找，就可以利用二分查找法来缩减时间复杂度。<br>我们可以在每一行中进行二分查找，快速定位目标值所在的行或列，进寻找目标值所在的位置，减少查找的时间复杂度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> target, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.<span class="built_in">empty</span>() || array[<span class="number">0</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>; <span class="comment">//（1）</span></span><br><span class="line">            <span class="type">int</span> right = array[i].<span class="built_in">size</span>()<span class="number">-1</span>; <span class="comment">//（2）</span></span><br><span class="line">            <span class="keyword">while</span>(left&lt;=right) &#123;</span><br><span class="line">                <span class="type">int</span> mid = (left + right )/<span class="number">2</span>; <span class="comment">// （3）</span></span><br><span class="line">                <span class="keyword">if</span>(target&gt;array[i][mid])</span><br><span class="line">                    left = mid + <span class="number">1</span>;<span class="comment">//（4）</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (target&lt;array[i][mid]) </span><br><span class="line">                    right = mid - <span class="number">1</span>; <span class="comment">//（5）</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//（6）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//（7）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（1）定义二分查找的左指针<br>（2）定义二分查找的右指针<br>（3）获取中间元素下表<br>（4）如果中间元素小于目标值，缩小左区间<br>（5）如果中间元素大于目标值，缩小右区间<br>（6）找到了返回<code>true</code><br>（7）没用找到返回<code>false</code></p><h2 id="3、利用题目特性">3、利用题目特性</h2><p>利用二维数组由上到下，由左到右递增的规律。<br>我们可以从矩阵的右上角（或左下角）开始查找，如果目标值比当前位置的值小，则说明目标值可能在当前位置的左边；如果目标值比当前位置的值大，则说明目标值可能在当前位置的下面。这样每次查找都可以将查找范围缩小一行或一列，最多需要进行 $m+n$ 次查找就可以找到目标值。</p><p><img src="https://zydx-520.oss-cn-beijing.aliyuncs.com/img/3%E6%9C%8818%E6%97%A5.gif" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> target, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断矩阵是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (array.<span class="built_in">empty</span>() || array[<span class="number">0</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; <span class="type">int</span> j = array[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">//（1）</span></span><br><span class="line">        <span class="keyword">while</span> ( i &lt; array.<span class="built_in">size</span>() &amp;&amp; j &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (target &lt;array[i][j]) &#123;</span><br><span class="line">                j--;  <span class="comment">// （2）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; array[i][j]) &#123;</span><br><span class="line">                i++;  <span class="comment">//（3）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（1）定义两个指针，分别指向第一行的第一个元素和第一行的最后一个元素。或者换句话说i指针控制的是行，j指针控制的是列，指针 i 指向第一行，指针 j 指向最后一列。<br>（2）如果当前位置的值大于目标值，说明当前列中的所有值都大于目标值，则将指针 j 左移一位。<br>（3）如果当前位置的值小于目标值，说明当前行中的所有值都小于目标值，则将指针 i 下移一位。</p><h1>三、代码总结</h1><h2 id="1、暴力法代码">1、暴力法代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> target, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; array)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> rows = array.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cols = array[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;rows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;j&lt;cols;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(array[i][j]==target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2、二分法代码">2、二分法代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> target, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> low = <span class="number">0</span>;<span class="type">int</span> col = array[i].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;=col)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid = (low + col )/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(target&gt;array[i][mid])</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (target&lt;array[i][mid])</span><br><span class="line">                    col = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3、利用特性">3、利用特性</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> target, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.<span class="built_in">empty</span>() || array[<span class="number">0</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; <span class="type">int</span> j = array[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">while</span> ( i &lt; array.<span class="built_in">size</span>() &amp;&amp; j &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (target &lt;array[i][j]) &#123;</span><br><span class="line">                j--;  </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; array[i][j]) &#123;</span><br><span class="line">                i++;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">剑指offer：二维数组中的查找</summary>
    
    
    
    <category term="刷题" scheme="https://www.zxhy.club/categories/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="剑指offer" scheme="https://www.zxhy.club/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
</feed>
